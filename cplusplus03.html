<html>
<head>
<title>C++ Annotations
        Version 4.4.0k </title>
</head>
<body fgcolor="black" bgcolor="white"  >
<hr>
<ul>
    <li> <a href="cplusplus04.html">Next chapter</a>
    <li> <a href="cplusplus02.html">Previous chapter</a>
    <li> <a href="cplusplus.html">Table of contents</a>
</ul>
<hr>

<a name="FirstImpression"></a><a name="l28"></a>
<h1>Chapter 3: A first impression of C++</h1> 
<a name="first"></a>
    

<blockquote>
    <em>
        We're always interested in getting feedback. E-mail us if you like
        this guide, if you think that important material is omitted, if you
        encounter errors in the code examples or in the documentation, if you
        find any typos, or generally just if you feel like e-mailing. Mail to
        <a href="http://www.icce.rug.nl/frank/">Frank Brokken</a>
        or use an
        <a href="http://www.icce.rug.nl/frank/efrank.html">e-mail form</a>.
        Please state the concerned document version, found in
        the title. 
    </em>
</blockquote>
<p><br>
<p><br><a name="first/first"></a>
    In this chapter the usage of <strong>C++</strong> is further explored. The possibility to
declare functions in <code>struct</code>s is further illustrated using examples. The
concept of a <code>class</code> is introduced.

<p><br><a name="l29"></a>
<h2>3.1: More extensions of C in C++</h2>
    <a name="first/more"></a>
    Before we continue with the `real' object-oriented approach to programming, we
first introduce some extensions to the <strong>C</strong> programming language,
encountered in <strong>C++</strong>: not mere differences between <strong>C</strong> and <strong>C++</strong>, but
syntactical constructs and keywords that are not found in <strong>C</strong>.
<p><br>
<p><br><a name="l30"></a>
<h3>3.1.1: The scope resolution operator ::</h3>
        <a name="first/scope"></a>
    
The syntax of <strong>C++</strong> introduces a number of new operators, of which the
scope resolution operator <code>::</code> is described first. This operator can be
used in situations where a global variable exists with the same name as a
local variable:
<p><br><pre>

    #include &lt;stdio.h&gt;

    int
        counter = 50;                   // global variable

    int main()
    {
        for (register int counter = 1;  // this refers to the 
             counter &lt; 10;              // local variable
             counter++)
        {
            printf("%d\n",
                    ::counter           // global variable
                    /                   // divided by
                    counter);           // local variable
        }
        return (0);
    }

</pre>

<p><br>In this code fragment the scope operator is used to address a global variable
instead of the local variable with the same name. The usage of the scope
operator is more extensive than just this, but the other purposes will be
described later.

<p><br>
    <a name="CoutCinCerr"></a><a name="l31"></a>
<h3>3.1.2: cout, cin and cerr</h3>
        <a name="first/cout"></a>
    In analogy to <strong>C</strong>, <strong>C++</strong> defines standard input- and output streams
which are opened when a program is executed. The streams are:
<p><br><ul>
<p><br><li > <code>cout</code>, analogous to <code>stdout</code>,
<p><br><li > <code>cin</code>, analogous to <code>stdin</code>,
<p><br><li > <code>cerr</code>, analogous to <code>stderr</code>.
<p><br></ul>
<p><br>Syntactically these streams are not used with functions: instead, data are
read from the streams or written to them using the operators <code>&lt;&lt;</code>, called
the <em>insertion operator</em> and <code>&gt;&gt;</code>, called the <em>extraction operator</em>. 
This is illustrated in the example below:
<p><br><pre>

    #include &lt;iostream&gt;

    void main()
    {
        int
            ival;
        char
            sval[30];

        cout &lt;&lt; "Enter a number:" &lt;&lt; endl;
        cin &gt;&gt; ival;
        cout &lt;&lt; "And now a string:" &lt;&lt; endl;
        cin &gt;&gt; sval;

        cout &lt;&lt; "The number is: " &lt;&lt; ival &lt;&lt; endl 
             &lt;&lt; "And the string is: " &lt;&lt; sval &lt;&lt; endl;
    }            

</pre>

<p><br>This program reads a number and a string from the <code>cin</code> stream (usually the
keyboard) and prints these data to <code>cout</code>. Concerning the streams and their
usage we remark the following:
<p><br><ul>
<p><br><li > The streams are declared in the header file <code>iostream</code>.
<p><br><li > The streams <code>cout</code>, <code>cin</code> and <code>cerr</code> are in fact `objects'
    of a given class (more on classes later), processing the input and
    output of a program. Note that the term `object', as used here, means the
    set of data and functions which defines the item in question.
<p><br><li > The stream <code>cin</code> reads data and copies the information to
    variables (e.g., <code>ival</code> in the above example) using the extraction
    operator <code>&gt;&gt;</code>. We will describe later how operators in <strong>C++</strong>
    can perform quite different actions than what they are defined to do by the
    language grammar, such as is the case here. We've seen function 
    overloading. In <strong>C++</strong> <em>operators</em> can also have multiple 
    definitions, which is called <em>operator overloading</em>.
<p><br><li > The operators which manipulate <code>cin</code>, <code>cout</code> and <code>cerr</code>
    (i.e., <code>&gt;&gt;</code> and <code>&lt;&lt;</code>) also manipulate variables of
    different types. In the above example <code>cout &lt;&lt; ival</code> results in the
    printing of an integer value, whereas <code>cout &lt;&lt; "Enter a number"</code>
    results in the printing of a string. The actions of the operators
    therefore depend on the type of supplied variables.
<p><br><li > Special symbolic constants are used for special situations. The
    termination of a line written by <code>cout</code> is realized by inserting the 
    <code>endl</code> symbol, rather than using the string <code>"\n"</code>. 
<p><br></ul>
<p><br>The streams <code>cin</code>, <code>cout</code> and <code>cerr</code> are in fact not part of the <strong>C++</strong>
grammar, as defined in the compiler which parses source files. The streams are
part of the definitions in the header file <code>iostream</code>. This is comparable
to the fact that functions as <code>printf()</code> are not part of the <strong>C</strong> grammar,
but were originally written by people who considered such functions handy and
collected them in a run-time library.
<p><br>Whether a program uses the old-style functions like <code>printf()</code> and
<code>scanf()</code> or whether it employs the new-style streams is a matter of taste.
Both styles can even be mixed. A number of advantages and disadvantages is
given below:
<p><br><ul>
<p><br><li > Compared to the standard <code>C</code> functions <code>printf()</code> and
    <code>scanf()</code>, the usage of the insertion and extraction operators
    is more <code>type-safe</code>.
    The format strings which are used with <code>printf()</code> and
    <code>scanf()</code> can define wrong format specifiers for their arguments,
    for which the compiler sometimes can't warn. In contrast, argument
    checking with <code>cin</code>, <code>cout</code> and <code>cerr</code> is performed
    by the compiler. Consequently it isn't possible to err by providing an
    <code>int</code> argument in places where, according to the format string, a string 
    argument should appear.
<p><br><li > The functions <code>printf()</code> and <code>scanf()</code>, and other
    functions which use format strings, in fact implement a mini-language
    which is interpreted at run-time. In contrast, the <code>C++</code> compiler
    knows exactly <code>which</code> in- or output action to perform given which
    argument.
<p><br><li > The usage of the left-shift and right-shift operators in the
    context of the streams does illustrate the possibilities of <code>C++</code>.
    Again, it requires a little getting used to, coming from <strong>C</strong>,
    but after that these overloaded operators feel rather comfortably.
<p><br></ul> 
<p><br>The <em>iostream library</em> has a lot more to offer than just <code>cin, cout</code> and
<code>cerr</code>. In chapter <a href="cplusplus11.html#IOStreams">11</a> <em>iostreams</em> will be covered in greater
detail.

<p><br>
    <a name="ConstRule"></a><a name="l32"></a>
<h3>3.1.3: The keyword const</h3>
        <a name="first/const"></a>
    The keyword <code>const</code> very often occurs in <strong>C++</strong> programs, even though it
is also part of the <strong>C</strong> grammar, where it's much less used.
<p><br>This keyword is a modifier which states that the value of a variable or of an
argument may not be modified. In the below example an attempt is made to
change the value of a variable <code>ival</code>, which is not legal:
<p><br><pre>

    int main()
    {
        int const               // a constant int..
            ival = 3;           // initialized to 3

        ival = 4;               // assignment leads
                                // to an error message

        return (0);
    }

</pre>

<p><br>This example shows how <code>ival</code> may be initialized to a given value in its
definition; attempts to change the value later (in an assignment) are not
permitted.
<p><br>Variables which are declared <code>const</code> can, in contrast to <strong>C</strong>, be used as
the specification of the size of an array, as in the following example:
<p><br><pre>

    int const
        size = 20;
    char
        buf[size];          // 20 chars big

</pre>

<p><br>A further usage of the keyword <code>const</code> is seen in the declaration of
pointers, e.g., in pointer-arguments. In the declaration
<p><br><pre>

    char const *buf;

</pre>

<p><br><code>buf</code> is a pointer variable, which points to <code>char</code>s. Whatever is
pointed to by <code>buf</code> may not be changed: the <code>char</code>s are declared as
<code>const</code>. The pointer <code>buf</code> itself however may be changed. A statement as
<code>*buf = 'a';</code> is therefore not allowed, while <code>buf++</code> is.
<p><br>In the declaration
<p><br><pre>

    char *const buf;

</pre>

<p><br><code>buf</code> itself is a <code>const</code> pointer which may not be changed. Whatever
<code>char</code>s are pointed to by <code>buf</code> may be changed at will.
<p><br>Finally, the declaration
<p><br><pre>

    char const *const buf;

</pre>

<p><br>is also possible; here, neither the pointer nor what it points to may be
changed.
<p><br>The rule of thumb for the placement of the keyword <code>const</code> is the
following: whatever occurs just prior to the keyword may not be changed.
The definition or declaration in which <code>const</code> is used should be read
from the variable or function identifier back to the type indentifier:
<blockquote>
    ``Buf is a const pointer to const characters''
</blockquote>
This rule of thumb is especially handy in cases where confusion may occur.
In examples of <strong>C++</strong> code, one often encounters the reverse: <code>const</code>
<em>preceding</em> what should not be altered. That this may result in sloppy
code is indicated by our second example above:
<p><br><pre>

    char const *buf;

</pre>

<p><br>What must remain constant here? According to the sloppy interpretation, the
pointer cannot be altered (since <code>const</code> precedes the pointer-*). In fact,
the charvalues are the constant entities here, as will be clear when it is 
tried to compile the following program:
<p><br><pre>

    int main()
    {
        char const *buf = "hello";
    
        buf++;                  // accepted by the compiler
        *buf = 'u';             // rejected by the compiler

        return (0);
    }

</pre>

<p><br>Compilation fails on the statement <code>*buf = 'u';</code>, <em>not</em> on the statement
<code>buf++</code>.

<p><br><a name="l33"></a>
<h3>3.1.4: References</h3>
        <a name="first/references"></a>
    
Besides the normal declaration of variables, <strong>C++</strong> allows `references' to
be declared as synonyms for variables. A reference to a variable is like an
alias; the variable name and the reference name can both be used in statements
which affect the variable:
<p><br><pre>

    int
        int_value;
    int
        &amp;ref = int_value;

</pre>

<p><br>In the above example a variable <code>int_value</code> is defined. Subsequently a
reference <code>ref</code> is defined, which due to its initialization addresses the
same memory location which <code>int_value</code> occupies. In the definition of
<code>ref</code>, the reference operator <code>&amp;</code> indicates that <code>ref</code> is not
itself an integer but a reference to one. The two statements
<p><br><pre>

    int_value++;            // alternative 1
    ref++;                  // alternative 2

</pre>

<p><br>have the same effect, as expected. At some memory location an <code>int</code> value
is increased by one --- whether that location is called <code>int_value</code> or
<code>ref</code> does not matter.
<p><br>References serve an important function in <strong>C++</strong> as a means to pass arguments
which can be modified (`variable arguments' in Pascal-terms). E.g., in
standard <strong>C</strong>, a function which increases the value of its argument by five
but which returns nothing (<code>void</code>), needs a pointer argument:
<p><br><pre>

    void increase(int *valp)        // expects a pointer
    {                               // to an int
        *valp += 5;
    }

    int main()
    {
        int
            x;

        increase(&amp;x)                // the address of x is
        return (0);                 // passed as argument
    }

</pre>

<p><br>This construction can <em>also</em> be used in <strong>C++</strong> but the same effect
can be achieved using a reference:
<p><br><pre>

    void increase(int &amp;valr)            // expects a reference
    {                                   // to an int
        valr += 5;
    }

    int main()
    {
        int
            x;

        increase(x);                    // a reference to x is 
        return (0);                     // passed as argument
    }

</pre>

<p><br>The way in which <strong>C++</strong> compilers implement references is actually by 
using pointers: in other words, references in <strong>C++</strong> are just ordinary
pointers, as far as the compiler is concerned.  However, the programmer does
not need to know or to bother about levels of indirection. (Compare
this to the Pascal way: an argument which is declared as <code>var</code> is in fact
also a pointer, but the programmer needn't know.)
<p><br>It can be argued whether code such as the above is clear: the statement
<code>increase</code> <code>(x)</code> in the <code>main()</code> function suggests that not <code>x</code>
itself but a <em>copy</em> is passed. Yet the value of <code>x</code> changes because of
the way <code>increase()</code> is defined.
<p><br>Our suggestions for the usage of references as arguments to functions are
therefore the following:
<p><br><ul>
<p><br><li > In those situations where a called function does not alter its
    arguments, a copy of the variable can be passed:
<p><br><pre>

        void some_func(int val)
        {
            printf("%d\n", val);
        }

        int main()
        {
            int
                x;

            some_func(x);           // a copy is passed, so
            return (0);             // x won't be changed
        }
    
</pre>

<p><br><li > When a function changes the value of its argument, the address 
    or a reference can be passed, whichever you prefer:
<p><br><pre>

        void by_pointer(int *valp)
        {
            *valp += 5;
        }

        void by_reference(int &amp;valr)
        {
            valr += 5;
        }

        int main ()
        {
            int
                x;

            by_pointer(&amp;x);             // a pointer is passed
            by_reference(x);            // x is altered by reference
            return (0);                 // x might be changed
        }
    
</pre>

<p><br><li > References have an important role in those cases where the argument
    will not be changed by the function, but where it is desirable to pass a
    reference to the variable instead of a copy of
    the whole variable. Such a situation occurs when a large variable, e.g., a
    <code>struct</code>, is passed as argument, or is returned from the function.
    In these cases the copying operations tend to become 
    significant factors when the entire structure must be copied, and it is
    preferred to use references. If the argument isn't changed by the 
    function, or if the caller shouldn't change the returned information,
    the use of the <code>const</code> keyword is appropriate and should be used.
<p><br>Consider the following example:
<p><br><pre>
    
    struct Person                       // some large structure
    {
        char
            name [80],
            address [90];
        double
            salary;
    };
            
    Person    
       person[50];                      // database of persons    

    void printperson (Person const &amp;p)  // printperson expects a
    {                                   // reference to a structure
        printf ("Name: %s\n"            // but won't change it
                "Address: %s\n",
        p.name, p.address);
    }
                
    Person const &amp;getperson(int index)  // get a person by indexvalue    
    {    
        ...
        return (person[index]);         // a reference is returned,    
    }                                   // not a copy of person[index]    

    int main ()
    {
        Person
            boss;

        printperson (boss);             // no pointer is passed,
                                        // so variable won't be    
                                        // altered by function
        printperson(getperson(5));      // references, not copies
                                        // are passed here
        return (0);
    }

</pre>

<p><br><li >  It should furthermore be noted here that there is another reason
    for using references when passing objects as function arguments: when
    passing a reference to an object, the activation of a copy constructor is
    avoided. We have to postpone this argument to chapter 
    <a href="cplusplus05.html#MemoryManagement">5</a>
<p><br></ul>
<p><br>References also can lead to extremely `ugly' code. A function can also return
a reference to a variable, as in the following example:
<p><br><pre>

    int &amp;func()
    {
        static int
            value;

        return (value);
    }

</pre>

<p><br>This allows the following constructions:
<p><br><pre>

    func() = 20;
    func() += func ();

</pre>

<p><br>It is probably superfluous to note that such constructions should not normally
be used. Nonetheless, there are situations where it is useful to return a
reference. Even though this is discussed later, we have seen an example
of this phenomenon at our previous discussion of the <em>iostreams</em>. In a 
statement like <code>cout &lt;&lt; "Hello" &lt;&lt; endl;</code>, the insertion operator returns
a reference to <code>cout</code>. So, in this statement first the <code>"Hello"</code> is
inserted into <code>cout</code>, producing a reference to <code>cout</code>. Via this reference
the <code>endl</code> is then inserted in the <code>cout</code> object, again producing a
reference to <code>cout</code>. This latter reference is not further used.
<p><br>A number of differences between pointers and references is pointed out in the
list below:
<p><br><ul>
<p><br><li > A reference cannot exist by itself, i.e., without something to
    refer to. A declaration of a reference like
<p><br><center><code>int &amp;ref;</code> </center>
<p><br>is not allowed; what would <code>ref</code> refer to? 
<p><br><li > References can, however, be declared as <code>external</code>.
    These references were initialized elsewhere.
<p><br><li > Reference may exist as parameters of functions: they are initialized
    when the function is called.
<p><br><li > References may be used in the return types of
    functions. In those cases the function determines to what the return 
    value will refer.
<p><br><li > Reference may be used as data members of classes. We will return
    to this usage later.
<p><br><li > In contrast, pointers are variables by themselves. They point at
    something concrete or just ``at nothing''.
<p><br><li > 

    References are aliases for other variables and cannot be re-aliased to
    another variable. Once a reference is defined, it refers to its particular
    variable.
<p><br><li > In contrast, pointers can be reassigned to point to different 
    variables.
<p><br><li > When an address-of operator <code>&amp;</code> is used with a reference,
    the expression yields the address of the variable to which the reference
    applies. In contrast, ordinary pointers are variables themselves, so the
    address of a pointer variable has nothing to do with the address of the
    variable pointed to.
<p><br></ul>
<p><br>
<p><br><a name="FunctionsInStructs"></a><a name="l34"></a>
<h2>3.2: Functions as part of structs</h2>
    <a name="first/structs"></a>
    The first chapter described that functions can be part of <code>struct</code>s (see
section <a href="cplusplus02.html#FunctionInStruct">2.5.16</a>).  Such functions are called <em>member
functions</em> or <em>methods</em>. 
This section discusses the actual definition of such functions.
<p><br>The code fragment below illustrates a <code>struct</code> in which data fields for a
name and address are present. A function <code>print()</code> is included in the
<code>struct</code> definition:
<p><br><pre>

    struct person
    {
        char
            name [80],
            address [80];
        void
            print (void);
    };

</pre>

<p><br>The member function <code>print()</code> is defined using the structure name
(<code>person</code>) and the scope resolution operator (<code>::</code>):
<p><br><pre>

    void person::print()
    {
        printf("Name:      %s\n"
               "Address:   %s\n", name, address);
    }

</pre>

<p><br>In the definition of this member function, the function name is preceded by
the <code>struct</code> name followed by <code>::</code>. The code of the function shows how
the fields of the <code>struct</code> can be addressed without using the type name: in
this example the function <code>print()</code> prints a variable <code>name</code>. Since
<code>print()</code> is a part of the <code>struct</code> <code>person</code>, the variable <code>name</code>
implicitly refers to the same type.
<p><br>The usage of this <code>struct</code> could be, e.g.:
<p><br><pre>

    person
        p;

    strcpy(p.name, "Karel");
    strcpy(p.address, "Rietveldlaan 37");
    p.print();

</pre>

<p><br>The advantage of member functions lies in the fact that the called function
can automatically address the data fields of the structure for which it was
invoked. As such, in the statement <code>p.print()</code> the structure <code>p</code> is the
`substrate': the variables <code>name</code> and <code>address</code> which are used in the
code of <code>print()</code> refer to the same <code>struct p</code>.

<p><br><a name="l35"></a>
<h2>3.3: Several new data types</h2>
    <a name="first/datatypes"></a>
    In <strong>C</strong> the following basic data types are available: <code>void, char, short,
int, long, float</code> and <code>double</code>. <strong>C++</strong> extends these five basic types with
several extra types: the types <code>bool, wchar_t</code> and <code>long double</code>. The type
<code>long double</code> is merely a double-long <code>double</code> datatype. Apart from these
basic types a standard type <code>string</code> is available. The datatypes <code>bool</code>,
<code>wchar_t</code> and <code>string</code> are covered in the following sections.
<p><br>
<p><br>
    <a name="BOOL"></a><a name="l36"></a>
<h3>3.3.1: The `bool' data type</h3>
        <a name="first/bool"></a>
    In <strong>C</strong> the following basic data types are available: <code>void, char, int,
float</code> and <code>double</code>. <strong>C++</strong> extends these five basic types with several
extra types. In this section the type <code>bool</code> is introduced.
<p><br>The type <code>bool</code> represents boolean (logical) values, for which the
(now reserved) values <code>true</code> and <code>false</code> may be used. Apart from these
reserved values, integral values may also be assigned to variables of type
<code>bool</code>, which are implicitly converted to <code>true</code> and <code>false</code> according
to the following conversion rules (assume <code>intValue</code> is an <code>int</code>-variable,
and <code>boolValue</code> is a <code>bool</code>-variable):
<pre>

        // from int to bool:
    boolValue = intValue ? true : false;

        // from bool to int:

    intValue = boolValue ? 1 : 0;

</pre>

Furthermore, when <code>bool</code> values are inserted into, e.g., <code>cout</code>, then
<code>1</code> is written for <code>true</code> values, and <code>0</code> is written for <code>false</code>
values. Consider the following example:
<pre>

    cout &lt;&lt; "A true value: "  &lt;&lt; true &lt;&lt; endl
         &lt;&lt; "A false value: " &lt;&lt; false &lt;&lt; endl;

</pre>

<p><br>The <code>bool</code> data type is found in other programming languages as
well. <strong>Pascal</strong> has its type <code>Boolean</code>, and <strong>Java</strong> has a <code>boolean</code>
type. Different from these languages, <strong>C++</strong>'s type <code>bool</code> acts like a kind
of <code>int</code> type: it's primarily a documentation-improving type, having just two
values <code>true</code> and <code>false</code>. Actually, these values can be interpreted as
<code>enum</code> values for <code>1</code> and <code>0</code>. Doing so would neglect the philosophy
behind the <code>bool</code> data type, but nevertheless: assigning <code>true</code> to an
<code>int</code> variable neither produces warnings nor errors.
<p><br>Using the <code>bool</code>-type is generally more intuitively clear than using
<code>int</code>. Consider the following prototypes:
<pre>

        bool exists(char const *fileName);  // (1)
        int  exists(char const *fileName);  // (2)

</pre>

For the first prototype <code>(1)</code>, most people will expect the function to
return <code>true</code> if the given filename is the name of an existing
file. However, using the second prototype some ambiguity arises: intuitively
the returnvalue 1 is appealing, as it leads to constructions like
<pre>

        if (exists("myfile"))
            cout &lt;&lt; "myfile exists";

</pre>

On the other hand, many functions (like <code>access(), stat(),</code> etc.) return
<code>0</code> to indicate a successful operation, reserving other values to indicate
various types of errors. 
<p><br>As a rule of thumb we suggest the following: If a function should inform its
caller about the success or failure of its task, let the function return a
<code>bool</code> value. If the function should return success or various types of
errors, let the function return <em>enum</em> values, documenting the situation
when the function returns. Only when the function returns a meaningful
integral value (like the sum of two <code>int</code> values), let the function return
an <code>int</code> value.

<p><br>
    <a name="WCHAR"></a><a name="l37"></a>
<h3>3.3.2: The `wchar_t' data type</h3>
        <a name="first/wchar"></a>
    The <code>wchar_t</code> type is an extension of the <code>char</code> basic type, to accomodate
<em>wide</em> character values, such as the <em>Unicode</em> character set.
<code>Sizeof(wchar_t)</code> is 2, allowing for 65,536 different character values.
<p><br>Note that a programming language like <strong>Java</strong> has a data type <code>char</code> that
is comparable to <strong>C++</strong>'s <code>wchar_t</code> type, while <strong>Java</strong>'s <code>byte</code> data
type is comparable to <strong>C++</strong>'s <code>char</code> type. Very convenient....
<p><br>
<p><br>
    <a name="STRING"></a><a name="l38"></a>
<h3>3.3.3: The `string' data type</h3>
        <a name="first/string"></a>
    <strong>C++</strong> offers a large number of facilities to implement solutions for common
problems. Most of these facilities are part of the <em>Standard Template
Library</em> or they are implemented as <em>generic algorithms</em> (see chapter
<a href="cplusplus10.html#STL">10</a>). 
<p><br>Among the facilities <strong>C++</strong> programmers have developed over and over again
(as reflected in the Annotations) are those for manipulating chunks of text,
commonly called <em>strings</em>. The <strong>C</strong> programming language offers rudimentary
string support: the <em>ascii-z</em> terminated series of characters is the
foundation on which a large amount of code has been built. 
<p><br>Standard <strong>C++</strong> now offers a <code>string</code> type of its own. In order to use
<code>string</code>-type objects, the header file <code>string</code> must be included in 
sources. 
<p><br>Actually, <code>string</code> objects are <em>class type</em> variables, and the <code>class</code>
is introduced for the first time in chapter <a href="cplusplus04.html#Classes">4</a>. However, in order to
use a string, it is not necessary to know what a class is. In this section the
operators that are available for strings and some other operations are
discussed. The operations that can be performed on strings take the form 
<p><br><center><code>stringVariable.operation(argumentList)</code> </center>
<p><br>For example, if <code>string1</code> and <code>string2</code> are variables of type <code>string</code>,
then 
<p><br><center><code>string1.compare(string2)</code> </center>
<p><br>can be used to compare both strings. A function like <code>compare()</code>, which is
part of the <code>string</code>-class is called a <em>memberfunction</em>. The <code>string</code>
class offers a large number of these memberfunctions, as well as extensions of
some well-known operators, like the assignment (<code>=</code>) and the comparison
operator (<code>==</code>). These operators and functions are discussed in the
following sections.
<p><br>
<p><br>
<a name="l39"></a>

             
<strong>3.3.3.1: Operations on strings</strong><p>
            <a name="first/stringops"></a>
    Some of the operations that can be performed on strings return indices within
the strings. Whenever such an operation fails to find an appropriate index,
the <em>value</em> <code>string::npos</code> is returned. This value is a (symbolic) value
of type <code>string::size_type</code>, which is (for all practical purposes) an
<code>int</code>. 
<p><br>Note that in all operations where <code>string</code> objects can be used as arguments,
<code>char const *</code> values and variables can be used as well.
<p><br>Some <code>string</code>-memberfunctions use <em>iterators</em>. Iterators will be covered
in section <a href="cplusplus10.html#ITERATORS">10.1</a>. The memberfunctions that use iterators are listed
in the next section (<a href="cplusplus03.html#STRINGOVERVIEW">3.3.3.2</a>), they are not further illustrated
below. 
<p><br>The following operations can be performed on strings:
<p><br><ul>
    <li > String objects can be <em>initialized</em>. For the initialization a plain
<code>ascii-z</code> string, another <code>string</code> object, or an implicit initialization
can be used. In the example, note that the implicit initialization does not
have an argument, and does not use the function argumentlist notation. 
        <pre>
    #include &lt;string&gt;
    
    int main()
    {
        string
            stringOne("Hello World"),   // using plain ascii-Z
            stringTwo(stringOne),       // using another string object
            stringThree;                // implicit initialization to ""
                                        // do not use: stringThree();    
        return (0);
    }
</pre>

<p><br><li > String objects can be assigned to each other. For this the assignment
operator (i.e., the <code>=</code> operator) can be used, which accepts both a
<code>string</code> object and a <strong>C</strong>-style characterstring as its right-hand
argument:
        <pre>
    #include &lt;string&gt;
    
    int main()
    {
        string
            stringOne("Hello World"),
            stringTwo;                  

        stringTwo = stringOne;      // assign stringOne to stringTwo
        stringTwo = "Hello world";  // assign a C-string to StringTwo

        return (0);
    }
</pre>

<p><br><li > In the previous example a standard <strong>C</strong>-string (an ascii-Z string) 
was implicitly
converted to a <code>string</code>-object. The reverse conversion (converting a
<code>string</code> object to a standard <strong>C</strong>-string) is not performed
automatically. In order to obtain the <code>C</code>-string that is stored within the
<code>string</code> object itself, the memberfunction <code>c_str()</code>, which returns a
<code>char const *</code>, can be used:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    
    int main()
    {
        string
            stringOne("Hello World");
        char const
            *Cstring = stringOne.c_str();

        cout &lt;&lt; Cstring &lt;&lt; endl;

        return (0);
    }
</pre>

<p><br><li > The individual elements of a string object can be reached for reading
or writing. For this operation the subscript-operator (<code>[]</code>) is available,
but <em>not</em> the pointer dereferencing operator (<code>*</code>). The subscript operator
does not perform range-checking. If range-checking is required, the <code>at()</code>
memberfunction can be used instead of the subscript-operator:
        <pre>
    #include &lt;string&gt;
    
    int main()
    {
        string
            stringOne("Hello World");

        stringOne[6] = 'w';         // now "Hello world"
        if (stringOne[0] == 'H')
            stringOne[0] = 'h';     // now "hello world"

        // THIS WON'T COMPILE:
        //  *stringOne = 'H';        

        // Now using the at() memberfunction:

        stringOne.at(6) = 
                stringOne.at(0);    // now "Hello Horld"
        if (stringOne.at(0) == 'H')
            stringOne.at(0) = 'W';  // now "Wello Horld"

        return (0);
    }
</pre>

    When an illegal index is passed to the <code>at()</code> memberfunction, the
program aborts. 
<p><br><li > Two strings can be compared for (in)equality or ordering, using the
<code>==, !=, &lt;, &lt;=, &gt;</code> and <code>&gt;=</code> operators or the <code>compare()</code> memberfunction
can be used. The <code>compare()</code> memberfunction comes in different flavors, the
plain one (having another <code>string</code> object as argument) offers a bit more
information than the operators do.  The returnvalue of the <code>compare()</code>
memberfunction may be used for lexicographical ordering: a negative value is
returned if the string stored in the string object using the <code>compare()</code>
memberfunction (in the example: <code>stringOne</code>) is located earlier in the
alphabet (based on the standard ascii-characterset) than the string stored in
the string object passed as argument to the <code>compare()</code>
memberfunction.
        <pre>
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    
    int main()
    {
        string
            stringOne("Hello World"),
            stringTwo;                  

        if (stringOne != stringTwo)
            stringTwo = stringOne;

        if (stringOne == stringTwo)
            stringTwo = "Something else";

        if (stringOne.compare(stringTwo) &gt; 0)
            cout &lt;&lt; "stringOne after stringTwo in the alphabet\n";
        else if (stringOne.compare(stringTwo) &lt; 0)
            cout &lt;&lt; "stringOne before stringTwo in the alphabet\n";
        else
            cout &lt;&lt; "Both strings are the same";

        // Alternatively:

        if (stringOne &gt; stringTwo)
            cout &lt;&lt; "stringOne after stringTwo in the alphabet\n";
        else if (stringOne &lt; stringTwo)
            cout &lt;&lt; "stringOne before stringTwo in the alphabet\n";
        else
            cout &lt;&lt; "Both strings are the same";

        return (0);
    }
</pre>

    There is memberfunction to perform a  case insensitive comparison of
strings. 
<p><br>Overloaded forms of the <code>compare()</code> memberfunction have one or
two extra arguments. 
    <ul>
    <li > If the <code>compare()</code> memberfunction is used with two arguments, then
the second argument is an index position in the current <code>string</code>-object. It
indicates the index position in the current <code>string</code> object where the
comparison should start.
    <li > If the <code>compare()</code> memberfunction is used with three arguments,
then the third argument indicates the number of characters that
should be compared.
     </ul>
    
    See the following example for further details about the <code>compare()</code>
function.
        <pre>
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    
    int main()
    {
        string
            stringOne("Hello World");

        // comparing from a certain offset in stringOne

        if (!stringOne.compare("ello World", 1))
            cout &lt;&lt; "comparing 'Hello world' from index 1"
                    " to 'ello World': ok\n";

        // comparing from a certain offset in stringOne over a certain 
        // number of characters in "World and more"

        if (!stringOne.compare("World and more", 6, 5))
            cout &lt;&lt; "comparing 'Hello World' from index 6 over 5 positions"
                    " to 'World and more': ok\n";

        // The same, but this fails, as all of the chars in stringOne 
        // starting at index 6 are compared, not just 3 chars.
        // number of characters in "World and more"

        if (!stringOne.compare("World and more", 6, 3))
            cout &lt;&lt; "comparing 'Hello World' from index 6 over 3 positions"
                    " to 'World and more': ok\n";
        else
            cout &lt;&lt; "Unequal (sub)strings\n";


        return (0);
    }
</pre>

<p><br><li > A <code>string</code> can be appended to another string. For this the <code>+=</code>
operator can be used, as well as the <code>append()</code> memberfunction. Furthermore,
the <code>+</code> operator can be used to append two strings within an expression:
     <pre>
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    
    int main()
    {
        string
            stringOne("Hello"),
            stringTwo("World");

        stringOne += " " + stringTwo;
        
        stringOne = "hello";
        stringOne.append(" world");

        // append only 5 characters:
        stringOne.append(" ok. &gt;This is not used&lt;", 5);

        cout &lt;&lt; stringOne &lt;&lt; endl;

        string
            stringThree("Hello");

        // append " World":
        stringThree.append(stringOne, 5, 6);

        cout &lt;&lt; stringThree &lt;&lt; endl;

        return (0);
    }
</pre>
 
 The <code>+</code> operator can be used in cases where the left-hand term of the <code>+</code>
operator is a <code>string</code> object and the right-hand term is a <code>string</code>
object, a <code>char const *</code> value or a <code>char</code>. Like the <code>compare()</code>
function, the <code>append()</code> memberfunction may have two extra arguments. The
first argument is the string to be appended, the second argument specifies the
index position of the first character that will be appended. The third
argument specifies the number of characters that will be appended. 
<p><br>When the left operand of the <code>+</code> operator is a <code>char const *</code> value or
variable, it must be converted to a <code>string</code> object first. The easiest way
to do this is probably to use an <em>anomymous string object</em>:
        <center><code>string("hello") + " world";</code> </center>
<p><br>If the first argument is of type <code>char const *</code>, only a second argument may
be specified. In that case, the second argument specifies the number of
characters of the first argument that are appended to the <code>string</code> object.
<p><br><li > So, the <code>append()</code> memberfunction is used to append characters at
the end of a <code>string</code>. It is also possible to insert characters
somewhere within a <code>string</code>. For this the memberfunction <code>insert()</code> is
available.
<p><br>The <code>insert()</code> memberfunction to insert (parts of) a <code>string</code> has at least
two, and at most four arguments:
    <ul>
    <li > The first argument is the offset in the current <code>string</code> object
where another string should be inserted. 
    <li > The second argument is the string to be inserted.
    <li > The third argument specifies the index position of the
first character in the provided <code>string</code>-argument that will be inserted.
    <li > The fourth argument specifies the number of characters that will be
inserted.
     </ul>
    If the first argument is of type <code>char const *</code>, the fourth argument is
not available. In that case, the third argument indicates the number of
characters of the provided <code>char const *</code> value that will be inserted.
        <pre>
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    
    int main()
    {
        string
            stringOne("Hell ok.");

        stringOne.insert(4, "o ");   // Insert "o " at position 4

        string
            world("The World of C++");

                                    // insert "World" into stringOne
        stringOne.insert(6, world, 4, 5);   

        cout &lt;&lt; "Guess what ? It is: " &lt;&lt; stringOne &lt;&lt; endl;

        return (0);
    }
</pre>

    Several other variants of <code>insert()</code> are available. See section
<a href="cplusplus03.html#STRINGOVERVIEW">3.3.3.2</a> for details.
<p><br><li > At times, the contents of <code>string</code> objects must be replaced by
other information. To replace parts of the contents of a <code>string</code> object by
another string the memberfunction <code>replace()</code> can be used. 
<p><br>The memberfunction has at least three and possibly five arguments, having
the following meanings
(see section <a href="cplusplus03.html#STRINGOVERVIEW">3.3.3.2</a> for overloaded versions of
<code>replace()</code>, using different types of arguments):
    <ul>
    <li > The first argument indicates the position of the first character that
must be replaced 
    <li > The second argument gives the number of characters that
must be replaced. 
    <li > The third argument defines the replacement text (a
<code>string</code> or <code>char const *</code>). 
    <li > The fourth argument specifies the index position of
the first character in the provided <code>string</code>-argument that will be inserted.
    <li > The fifth argument can be used to specify the number of
characters that will be inserted.
     </ul>
    If the third argument is of type <code>char const *</code>, the fifth argument is
not available. In that case, the fourth argument indicates the number of
characters of the provided <code>char const *</code> value that will be inserted. 
<p><br>The following example shows a very simple <em>filechanger</em>: it reads lines from
<code>cin</code>, and replaces occurrences of a `searchstring' by a
`replacestring'. Simple tests for the correct number of arguments and the
contents of the provided strings (they should be unequal) are implemented
using the <code>assert()</code> macro.  <a name="REPLACECC"></a>
        <pre>
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    #include &lt;cassert&gt;
    
    int main(int argc, char **argv)
    {
        assert(argc == 3 &amp;&amp; 
            "Usage: &lt;searchstring&gt; &lt;replacestring&gt; to process stdin");
            
        string
            line,
            search(argv[1]),    
            replace(argv[2]);

        assert(search != replace);

        while (getline(cin, line))
        {
            while (true)
            {
                string::size_type
                    idx;

                idx = line.find(search);

                if (idx == string::npos)
                    break;

                line.replace(idx, search.size(), replace);
            }                        
            cout &lt;&lt; line &lt;&lt; endl;
        }
        return (0);
    }

</pre>

<p><br><li > A particular form of replacement is swapping: the memberfunction
<code>swap()</code> swaps the contents of two <code>string</code>-objects. For example:
        <pre>
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    
    int main()
    {
        string
            stringOne("Hello"),
            stringTwo("World");
        
        cout &lt;&lt; "Before: stringOne: " &lt;&lt; stringOne &lt;&lt; ", stringTwo: "
            &lt;&lt; stringTwo &lt;&lt; endl;

        stringOne.swap(stringTwo);

        cout &lt;&lt; "After: stringOne: " &lt;&lt; stringOne &lt;&lt; ", stringTwo: "
            &lt;&lt; stringTwo &lt;&lt; endl;
        return (0);
    }
</pre>

<p><br><li > Another form of replacement is to remove characters from the
string. For this the memberfunction <code>erase()</code> is available. The standard
form has two optional arguments:
    <ul>
    <li > If no arguments are specified, the stored string is erased
completely: it becomes the empty string (<code>string()</code> or <code>string("")</code>).
    <li > The first argument may be used to specify the offset of the first
character that must be erased. 
    <li > The second argument may be used to specify the number of characters
that are to be erased.  
     </ul>
    See section <a href="cplusplus03.html#STRINGOVERVIEW">3.3.3.2</a> for overloaded versions of <code>erase()</code>. An
example of the use of <code>erase()</code> is given below:
        <pre>
    #include &lt;string&gt;
    
    int main()
    {
        string
            stringOne("Hello Cruel World");

        stringOne.erase(5, 6);

        cout &lt;&lt; stringOne &lt;&lt; endl;

        stringOne.erase();

        cout &lt;&lt; "'" &lt;&lt; stringOne &lt;&lt; "'\n";

        return (0);
    }
</pre>

<p><br><li > To find substrings in a <code>string</code> the memberfunction <code>find()</code> can
be used. This function looks for the string that is provided as its first
argument in the <code>string</code> object calling <code>find()</code> and returns the index of
the first character of the substring if found. If the string is not found
<code>string::npos</code> is returned. The memberfunction <code>rfind()</code> looks for the
substring from the end of the <code>string</code> object back to its beginning. An
example using <code>find()</code> was given <a href="cplusplus03.html#REPLACECC">earlier.</a>
<p><br><li > To extract a substring from a <code>string</code> object, the memberfunction
<code>substr()</code> is available. The returned <code>string</code> object contains a copy of
the substring in the <code>string</code>-object calling <code>substr()</code> The memberfunction
has two optional arguments: 
    <ul>
    <li > Without arguments, a cpopy of the <code>string</code> itself is returned.
    <li > The first argument may be used to specify the offset of the first
character to be returned. 
    <li > The second argument may be used to specify the number of characters
that are to be returned. 
     </ul>
    For example:
        <pre>
    #include &lt;string&gt;
    
    int main()
    {
        string
            stringOne("Hello World");

        cout &lt;&lt; stringOne.substr(0, 5)  &lt;&lt; endl
             &lt;&lt; stringOne.substr(6)     &lt;&lt; endl
             &lt;&lt; stringOne.substr()      &lt;&lt; endl;

        return (0);
    }
</pre>

<p><br><li > Whereas <code>find()</code> is used to find a substring, the functions
<code>find_first_of(), find_first_not_of(), find_last_of()</code> and
<code>find_last_not_of()</code> can be used to find <em>sets</em> of characters
(Unfortunately, regular expressions are not supported here). The
following program reads a line of text from the standard input stream, and
displays the substrings starting at the first vowel, starting at the last
vowel, and not starting at the first digit:
        <pre>
    #include &lt;string&gt;
    
    int main()
    {
        string
            line;

        getline(cin, line);

        string::size_type
            pos;

        cout &lt;&lt; "Line: " &lt;&lt; line &lt;&lt; endl 
            &lt;&lt; "Starting at the first vowel:\n"
            &lt;&lt; "'" 
                &lt;&lt; (
                    (pos = line.find_first_of("aeiouAEIOU")) != string::npos ?
                        line.substr(pos) 
                    : 
                        "*** not found ***"
                    ) &lt;&lt; "'\n"
            &lt;&lt; "Starting at the last vowel:\n"
            &lt;&lt; "'" 
                &lt;&lt; (
                    (pos = line.find_last_of("aeiouAEIOU")) != string::npos ?
                        line.substr(pos) 
                    : 
                        "*** not found ***"
                    ) &lt;&lt; "'\n"
            &lt;&lt; "Not starting at the first digit:\n"
            &lt;&lt; "'" 
                &lt;&lt; (
                    (pos = line.find_first_not_of("1234567890"))
                                                            != string::npos ?
                        line.substr(pos) 
                    : 
                        "*** not found ***"
                    ) &lt;&lt; "'\n";
        return (0);
    }
</pre>

<p><br><li > The number of characters that are stored in a string are obtained by
the <code>size()</code> memberfunction, which, like the standard <strong>C</strong> function
<code>strlen()</code> does not include the terminating ascii-Z character. For example:
     <pre>
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    
    int main()
    {
        string
            stringOne("Hello World");

        cout &lt;&lt; "The length of the stringOne string is " 
            &lt;&lt; stringOne.size() &lt;&lt; " characters\n";

        return (0);
    }
</pre>

<p><br><li > If the size of a string is not enough (or if it is too large), the
memberfunction <code>resize()</code> can be used to make it longer or shorter. Note
that operators like <code>+</code> automatically resize the <code>string</code> when needed.
<p><br><li > The <code>size()</code> memberfunction can be used to determine whether a
string holds no characters as well. Alternatively, the <code>empty()</code>
memberfunction can be used:
     <pre>
    #include &lt;iostream&gt;
    #include &lt;string&gt;
    
    int main()
    {
        string
            stringOne;

        cout &lt;&lt; "The length of the stringOne string is " 
            &lt;&lt; stringOne.size() &lt;&lt; " characters\n" 
                "It is " &lt;&lt; (stringOne.empty() ? "" : " not ") 
            &lt;&lt; "empty\n";

        stringOne = "";
        
        cout &lt;&lt; "After assigning a \"\"-string to a string-object\n"
                "it is " &lt;&lt; (stringOne.empty() ? "also" : " not") 
            &lt;&lt; " empty\n";
        

        return (0);
    }
</pre>

<p><br><li > The <code>istream &amp;getline(istream instream, string target, char
delimiter)</code> memberfunction may be used to read a line of text (up to
the first delimiter or the end of the stream) from <code>instream</code>. 
<p><br>The delimiter has a default value <code>'\n'</code>. It is removed from <code>instream</code>,
but it is <em>not</em> stored in <code>target</code>. The function <code>getline()</code> was used in
several earlier examples (e.g., with the <a href="cplusplus03.html#REPLACECC">replace()</a>
memberfunction).
     </ul>

<p><br><a name="STRINGOVERVIEW"></a>
<a name="l40"></a>

             
<strong>3.3.3.2: Overview of operations on strings</strong><p>
            <a name="first/stringoverview"></a>
    In this section the available operations on strings are summarized. There are
four subparts here: the <code>string</code>-initializers, the <code>string</code>-iterators, the
<code>string</code>-operators and the <code>string</code>-memberfunctions. 
<p><br>The memberfunctions are ordered alphabetically by the name of the
operation. Below, <code>object</code> is a <code>string</code>-object, and <code>argument</code> is
either a <code>string</code> or a <code>char const *</code>, unless overloaded versions tailored
to <code>string</code> and <code>char const *</code> parameters are explicitly
mentioned. <code>Object</code> is used in cases where a <code>string</code> object is
initialized or given a new value. <code>Argument</code> remains unchanged. Sometimes
multiple arguments are required, in which case <code>argument1, argument2</code> etc.
are used.
<p><br>With memberfunctions the types of the parameters are given in a
function-prototypical way. With several memberfunctions <em>iterators</em> are
used. At this point in the Annotations it's a bit premature to discuss
iterators, but for referential purposes they have to be mentioned
nevertheless. So, a forward reference is used here: see section <a href="cplusplus10.html#ITERATORS">10.1</a>
for a more detailed discussion of <em>iterators</em>.
<p><br>Finally, note that all <code>string</code>-memberfunctions returning indices in 
<code>object</code> return the predefined constant <code>string::pos</code> if no
suitable index could be found.
    <ul>
    <li><strong>The string-initializers:</strong>
        <a name="first/stringinitializers"></a>
        <li><strong>The <code>string</code>-iterators:</strong> 
        <a name="first/stringiterators"></a>
        <li><strong>The <code>string</code>-operators:</strong>
        <a name="first/stringoperators"></a>
        <li><strong>The string memberfunctions:</strong>
        <a name="first/stringmembers"></a>
        </ul>
        <ul>
        <li ><code>char &amp;object.at(string::size_type pos)</code>: The character (reference)
at the indicated position is returned (it may be reassigned). The
memberfunction performs range-checking, aborting the program if an invalid
index is passed.
        <li ><code>string &amp;object.append(InputIterator begin, InputIterator end)</code>:
Using this memberfunction the range of characters implied by the <code>begin</code> and
<code>end InputIterators</code> are appended to <code>object</code>. 
        <li ><code>string &amp;object.append(string argument, string::size_type pos = 0;
string::size_type n = string::npos)</code>:
            <ul>
            <li > If only <code>argument</code> is given, it is appended to <code>object</code>. 
            <li > If <code>pos</code> is specified as well, <code>argument</code> is appended from
index position <code>pos</code> until the end of <code>argument</code>.
            <li > If all three arguments are provided, <code>n</code> characters of
<code>argument</code>, starting at index position <code>pos</code> are appended to <code>object</code>.
             </ul> 
    If <code>argument</code> is of type <code>char const *</code>, parameter <code>pos</code>
is not available.  So, with <code>char const *</code> arguments, either <em>all</em>
characters or an <em>initial subset</em> of the characters of the provided <code>char
const *</code> argument are appended to <code>object</code>.
            <ul>
            <li ><code>string &amp;object.append(string::size_type n, char c)</code>: Using this
memberfunction, <code>n</code> characters <code>c</code> can be appended to <code>object</code>.
             </ul>
        <li ><code>string &amp;object.assign(string argument, string::size_type pos = 0;
string::size_type n = string::npos)</code>:
            <ul>
            <li > If only <code>argument</code> is given, it is assigned to <code>object</code>. 
            <li > If <code>pos</code> is specified as well, <code>object</code> is assigned from
index position <code>pos</code> until the end of <code>argument</code>.
            <li > If all three arguments are provided, <code>n</code> characters of
<code>argument</code>, starting at index position <code>pos</code> are assigned to <code>object</code>.
             </ul>
    If <code>argument</code> is of type <code>char const *</code>, no parameter <code>pos</code> is
available.  So, with <code>char const *</code> arguments, either <em>all</em> characters or
an <em>initial subset</em> of the characters of the provided <code>char const *</code>
argument are assigned to <code>object</code>.
            <ul>
            <li ><code>string &amp;object.assign(string::size_type n, char c)</code>: Using this
memberfunction, <code>n</code> characters <code>c</code> can be assigned to <code>object</code>.
             </ul>
        <li ><code>string::size_type argument.capacity()</code>: returns the number of characters
that can currently be stored inside <code>argument</code>.
        <li ><code>int argument1.compare(string argument2, string::size_type pos, string::size_type
n)</code>: This memberfunction may be used to compare (according to the
ascii-character set) the strings stored in <code>argument1</code> and <code>argument2</code>. The
parameter <code>n</code> may be used to specify the number of characters in
<code>argument2</code> that are used in the comparison, the parameter <code>pos</code> may be
used to specify the initial character in <code>argument1</code> that is used in the
comparison.
        
        <li ><code>char const *argument.c_str</code>: the memberfunction returns the
contents of <code>argument</code> as an <code>ascii-Z</code> <strong>C</strong>-string.
        <li ><code>char const *argument.data()</code>: returns the raw text stored in
<code>argument</code>.
        <li ><code>bool argument.empty()</code>: returns <code>true</code> if <code>argument</code> contains
no data.
        <li ><code>string &amp;object.erase(string::size_type pos; string::size_type n)</code>. This
memberfunction can be used to erase (a sub)string of <code>object</code>. The basic
form erases <code>object</code> completely. The working of other forms of <code>erase()</code>
depend on the specification of extra arguments:
            <ul>
            <li > If <code>pos</code> is specified, the contents of <code>object</code> are erased
from index position <code>pos</code> until the end of <code>object</code>.
            <li > If <code>pos</code> and <code>n</code> are provided, <code>n</code> characters of
<code>object</code>, starting at index position <code>pos</code> are erased.
             </ul>
        <li ><code>iterator object.erase(iterator p)</code>: The contents of <code>object</code> are
erased until (iterator) position <code>p</code>. The iterator <code>p</code> is
returned.
        <li ><code>iterator object.erase(iterator f, iterator l)</code>: The range of
characters of <code>object</code>, implied by the <code>iterators f</code> and <code>l</code> are erased.
The iterator <code>f</code> is returned. 
        <li ><code>string::string::size_type argument1.find(string argument2, string::size_type pos)</code>:
This memberfunction returns the index in <code>argument1</code> where <code>argument2</code> is
found. If <code>pos</code> is omitted, the search starts at the beginning of
<code>argument1</code>. If <code>pos</code> is provided, it refers to the index in <code>argument1</code>
where the search for <code>argument2</code> should start.
        <li ><code>string::size_type argument1.find(char const *argument2,
string::size_type pos, string::size_type n)</code>: This memberfunction returns the
index in <code>argument1</code> where <code>argument2</code> is found. The parameter <code>n</code>
indicates the number of characters of <code>argument2</code> that should be used in the
search: it defines a partial string starting at the beginning of
<code>argument2</code>. If omitted, all characters in <code>argument2</code> are used.  The
parameter <code>pos</code> refers to the index in <code>argument1</code> where the search for
<code>argument2</code> should start. If the parameter <code>pos</code> is omitted as well, 
<code>argument1</code>  is scanned completely.
        <li ><code>string::size_type argument.find(char c, string::size_type pos)</code>:
This memberfunction returns the index in <code>argument</code> where <code>c</code> is found. If
the argument <code>pos</code> is omitted, the search starts at the beginning of
<code>argument</code>. If provided, it refers to the index in <code>argument</code> where the
search for <code>argument</code> should start.
        <li ><code>string::size_type argument1.find_first_of(string argument2,
string::size_type pos)</code>: This memberfunction returns the index in
<code>argument1</code> where any character in <code>argument2</code> is found. If the argument
<code>pos</code> is omitted, the search starts at the beginning of <code>argument1</code>. If
provided, it refers to the index in <code>argument1</code> where the search for
<code>argument2</code> should start.
        <li ><code>string::size_type argument1.find_first_of(char const* argument2,
string::size_type pos, string::size_type n)</code>: This memberfunction returns the
index in <code>argument1</code> where a character of <code>argument2</code> is found, no matter
which character.  The parameter <code>n</code> indicates the number of characters of
<code>argument1</code> that should be used in the search: it defines a partial string
starting at the beginning of <code>argument1</code>. If omitted, all characters in
<code>argument1</code> are used.  The parameter <code>pos</code> refers to the index in
<code>argument1</code> where the search for <code>argument2</code> should start. If the
parameter <code>pos</code> is omitted as well, <code>argument1</code> is scanned completely.
        <li ><code>string::size_type argument.find_first_of(char c, string::size_type
pos)</code>: This memberfunction returns the index in <code>argument1</code> where character
<code>c</code> is found. If the argument <code>pos</code> is omitted, the search starts at the
beginning of <code>argument1</code>. If provided, it refers to the index in
<code>argument1</code> where the search for <code>argument</code> should start.
        <li ><code>string::size_type argument1.find_first_not_of(string argument2,
string::size_type pos)</code>: This memberfunction returns the index in
<code>argument1</code> where a character not appearing in <code>argument2</code> is found. If
the argument <code>pos</code> is omitted, the search starts at the beginning of
<code>argument1</code>. If provided, it refers to the index in <code>argument1</code> where the
search for <code>argument2</code> should start.
        <li ><code>string::size_type argument1.find_first_not_of(char const*
argument2, string::size_type pos, string::size_type n)</code>: This memberfunction
returns the index in <code>argument1</code> where any character not appearing in
<code>argument2</code> is found.  The parameter <code>n</code> indicates the number of
characters of <code>argument1</code> that should be used in the search: it defines a
partial string starting at the beginning of <code>argument1</code>. If omitted, all
characters in <code>argument1</code> are used.  The parameter <code>pos</code> refers to the
index in <code>argument1</code> where the search for <code>argument2</code> should start. If the
parameter <code>pos</code> is omitted as well, <code>argument1</code> is scanned completely.
        <li ><code>string::size_type argument.find_first_not_of(char c,
string::size_type pos)</code>: This memberfunction returns the index in
<code>argument</code> where another character than <code>c</code> is found. If the argument
<code>pos</code> is omitted, the search starts at the beginning of <code>argument</code>. If
provided, it refers to the index in <code>argument</code> where the search for
<code>c</code> should start.
        <li ><code>string::size_type argument1.find_last_of(string argument2,
string::size_type pos)</code>: This memberfunction returns the last index in
<code>argument1</code> where a character in <code>argument2</code> is found. If the argument
<code>pos</code> is omitted, the search starts at the beginning of <code>argument1</code>. If
provided, it refers to the index in <code>argument1</code> where the search for
<code>argument2</code> should start.
        <li ><code>string::size_type argument1.find_last_of(char const* argument2,
string::size_type pos, string::size_type n)</code>: This memberfunction returns the
last index in <code>argument1</code> where a character of <code>argument2</code> is found.  The
parameter <code>n</code> indicates the number of characters of <code>argument1</code> that
should be used in the search: it defines a partial string starting at the
beginning of <code>argument1</code>. If omitted, all characters in <code>argument1</code> are
used.  The parameter <code>pos</code> refers to the index in <code>argument1</code> where the
search for <code>argument2</code> should start. If the parameter <code>pos</code> is omitted as
well, <code>argument1</code> is scanned completely.
        <li ><code>string::size_type argument.find_last_of(char c, string::size_type
pos)</code>: This memberfunction returns the last index in <code>argument</code> where
character <code>c</code> is found. If the argument <code>pos</code> is omitted, the search
starts at the beginning of <code>argument</code>. If provided, it refers to the index
in <code>argument</code> where the search for <code>c</code> should start.
        <li ><code>string::size_type argument1.find_last_not_of(string argument2,
string::size_type pos)</code>: This memberfunction returns the last index in
<code>argument1</code> where any character not appearing in <code>argument2</code> is found. If
the argument <code>pos</code> is omitted, the search starts at the beginning of
<code>argument1</code>. If provided, it refers to the index in <code>argument1</code> where the
search for <code>argument2</code> should start.
        <li ><code>string::size_type argument1.find_last_not_of(char const*
argument2, string::size_type pos, string::size_type n)</code>: This memberfunction
returns the last index in <code>argument1</code> where any character not appearing in
<code>argument2</code> is found.  The parameter <code>n</code> indicates the number of
characters of <code>argument1</code> that should be used in the search: it defines a
partial string starting at the beginning of <code>argument1</code>. If omitted, all
characters in <code>argument1</code> are used.  The parameter <code>pos</code> refers to the
index in <code>argument1</code> where the search for <code>argument2</code> should start. If the
parameter <code>pos</code> is omitted as well, all of <code>argument1</code> is scanned.
        <li ><code>string::size_type argument.find_last_not_of(char c,
string::size_type pos)</code>: This memberfunction returns the last index in
<code>argument</code> where another character than <code>c</code> is found. If the argument
<code>pos</code> is omitted, the search starts at the beginning of <code>argument</code>. If
provided, it refers to the index in <code>argument</code> where the search for <code>c</code>
should start.
        <li ><code>istream &amp;getline(istream instream, string object, char
delimiter)</code>.  This memberfunction can be used to read a line of text (up to
the first delimiter or the end of the stream) from <code>instream</code>. The delimiter
has a default value <code>'\n'</code>. It is removed from <code>instream</code>, but it is not
stored in <code>object</code>.
        <li ><code>string &amp;object.insert(string::size_type t_pos, string argument,
string::size_type pos; string::size_type n)</code>. This memberfunction can be used
to insert (a sub)string of <code>argument</code> into <code>object</code>, <em>at</em> <code>object</code>'s
index position <code>t_pos</code>. The basic form inserts <code>argument</code> completely at
index <code>t_pos</code>. The way other forms of <code>insert()</code> work depend on the
specification of extra arguments:
            <ul>
            <li > If <code>pos</code> is specified, <code>argument</code> is inserted from
index position <code>pos</code> until the end of <code>argument</code>.
            <li > If <code>pos</code> and <code>n</code> are provided, <code>n</code> characters of
<code>argument</code>, starting at index position <code>pos</code> are inserted into <code>object</code>.
             </ul>
    If <code>argument</code> is of type <code>char const *</code>, no parameter <code>pos</code> is
available.  So, with <code>char const *</code> arguments, either <em>all</em> characters or
an <em>initial subset</em> of the characters of the provided <code>char const *</code>
argument are inserted into <code>object</code>.
            <ul>
            <li ><code>string &amp;object.insert(string::size_type t_pos,
string::size_type n, char c)</code>: Using this memberfunction, <code>n</code> characters
<code>c</code> can be inserted to <code>object</code>.
             </ul>
        <li ><code>iterator object.insert(iterator p, char c)</code>: The character <code>c</code>
is inserted at the (iterator) position <code>p</code> in <code>object</code>. The iterator <code>p</code>
is returned.
        <li ><code>iterator object.insert(iterator p, string::size_type n, char c)</code>:
<code>N</code> characters <code>c</code> are inserted at the (iterator) position <code>p</code> in
<code>object</code>. The iterator <code>p</code> is returned.
        <li ><code>iterator object.insert(iterator p, InputIterator first,
InputIterator last)</code>: The range of characters implied by the <code>InputIterators
first</code> and <code>last</code> are inserted at the (iterator) position <code>p</code> in
<code>object</code>. The iterator <code>p</code> is returned.
        <li ><code>string::size_type argument.length()</code>: returns the number of
characters stored in <code>argument</code>.
        <li ><code>string::size_type argument.max_size()</code>: returns the maximum number
of characters that can be stored in <code>argument</code>.
        <li ><code>string&amp; object.replace(string::size_type pos1, string::size_type
n1, const string argument, string::size_type pos2, string::size_type n2)</code>: The
substring of <code>n1</code> characters of <code>object</code>, starting at position <code>pos1</code> is
replaced by <code>argument</code>. If <code>n1</code> is set to 0, the memberfunction
<em>inserts</em> <code>argument</code> into <code>object</code>.<br>
        The basic form uses <code>argument</code> completely. The way other
forms of <code>replace()</code> work depends on the specification of extra arguments:
            <ul>
            <li > If <code>pos2</code> is specified, <code>argument</code> is inserted from
index position <code>pos2</code> until the end of <code>argument</code>.
            <li > If <code>pos2</code> and <code>n2</code> are provided, <code>n2</code> characters of
<code>argument</code>, starting at index position <code>pos2</code> are inserted into <code>object</code>.
             </ul>
    If <code>argument</code> is of type <code>char const *</code>, no parameter <code>pos2</code> is
available.  So, with <code>char const *</code> arguments, either <em>all</em> characters or
an <em>initial subset</em> of the characters of the provided <code>char const *</code>
argument are replaced in <code>object</code>.
        <li ><code>string &amp;object.replace(string::size_type pos, string::size_type
n1, string::size_type n2, char c)</code>: This memberfunction can be used to replace
<code>n1</code> characters of <code>object</code>, starting at index position <code>pos</code>, by <code>n2
c</code>-characters. The argument <code>n2</code> may be omitted, in which case the string to
be replaced is replaced by just one character <code>c</code>.
        <li ><code>string&amp; object.replace (iterator i1, iterator i2, string
argument)</code>: Here, the string implied by the iterators <code>i1</code> and <code>i2</code> are
replaced by the string <code>str</code>. If <code>argument</code> is a <code>char const *</code>, an
extra argument <code>n</code> may be used, specifying the number of characters of
<code>argument</code> that are used in the replacement.
        <li ><code>iterator object.replace(iterator f, iterator l, string argument)</code>:
The range of characters of <code>object</code>, implied by the <code>iterators f</code> and
<code>l</code> are replaced by <code>argument</code>.  If <code>argument</code> is a <code>char const *</code>, an
extra argument <code>n</code> may be used, specifying the number of characters of
<code>argument</code> that are used in the replacement. The string <code>object</code> is
returned.
        <li ><code>iterator object.replace(iterator f, iterator l, string::size_type
n, char c)</code>: The range of characters of <code>object</code>, implied by the
<code>iterators f</code> and <code>l</code> are replaced by <code>n c</code>-characters. The iterator
<code>f</code> is returned.
        <li ><code>string object.replace(iterator i1, iterator i2, InputIterator j1,
InputIterator j2)</code>: here the range of characters implied by the iterators
<code>i1</code> and <code>i2</code> is replaced by the range of characters implied by the
<code>InputIterators j1</code> and <code>j2</code>.
        <li ><code>void object.resize(string::size_type n, char c)</code>: The string
stored in <code>object</code> is resized to <code>n</code> characters. The second argument is
optional. If provided and the string is enlarged, the extra characters are
initialized to <code>c</code>.
        <li ><code>string::size_type argument1.rfind(string argument2, string::size_type
pos)</code>: This memberfunction returns the index in <code>argument1</code> where <code>argument2</code>
is found. Searching proceeds from the end of <code>argument1</code> back to the
beginning. If the argument2 <code>pos</code> is omitted, the search starts at the
beginning of <code>argument1</code>. If provided, it refers to the index in <code>argument1</code>
where the search for <code>argument2</code> should start.
        <li ><code>string::size_type argument1.rfind(char const *argument2,
string::size_type pos, string::size_type n)</code>: This memberfunction returns the
index in <code>argument1</code> where <code>argument2</code> is found. Searching proceeds from
the end of <code>argument1</code> back to the beginning.  The parameter <code>n</code> indicates
the number of characters of <code>argument2</code> that should be used in the search:
it defines a partial string starting at the beginning of <code>argument2</code>. If
omitted, all characters in <code>argument2</code> are used.  The parameter <code>pos</code>
refers to the index in <code>argument1</code> where the search for <code>argument2</code> should
start. If the parameter <code>pos</code> is omitted as well, all of <code>argument1</code> is
scanned.
        <li ><code>string::size_type argument1.rfind(char c, string::size_type pos)</code>:
This memberfunction returns the index in <code>argument1</code> where <code>c</code> is found.
Searching proceeds from the end of <code>argument1</code> back to the beginning. If the
argument2 <code>pos</code> is omitted, the search starts at the beginning of
<code>argument1</code>. If provided, it refers to the index in <code>argument1</code> where the
search for <code>argument2</code> should start.
        <li ><code>string::size_type argument.size()</code>: returns the number of
characters stored in <code>argument</code>.
        <li ><code>string argument.substr(string::size_type pos, string::size_type
n)</code>: This memberfunction returns a substring of <code>argument</code>. The parameter
<code>n</code> may be used to specify the number of characters of <code>argument</code> that are
returned. The parameter <code>pos</code> may be used to specify the index of the first
character of <code>argument</code> that is returned. Either <code>n</code> or both arguments may
be omitted.
        <li ><code>string::size_type object1.swap(string object2)</code>: swaps the
contents of the <code>object1</code> and <code>object2</code>. In this case, <code>object2</code> cannot
be a <code>char const *</code>.
         </ul>
<p><br>
        <ul>
        <li ><code>object = argument</code>.  Assignment of <code>argument</code> to <code>object</code>.
May also be used for initializing <code>string</code> objects.
        <li ><code>object = c</code>.  Assignment of <code>char c</code> to <code>object</code>.  May
<em>not</em> be used for initializing <code>string</code> objects.
        <li ><code>object += argument</code>. Appends <code>argument</code> to
<code>object</code>. <code>Argument</code> may also be a <code>char</code> value.
        <li ><code>argument1 + argument2</code>. Within expressions, <code>strings</code> may be
added. The right-hand term may be a <code>string</code> object, a <code>char const *</code>
value or a <code>char</code> value. Note that the <em>left-hand</em> operand must be a
<code>string</code> object. So, in the following example the first expression will
compile correctly, but the second expression won't compile:
            <pre>

    void fun()
    {
        char const 
            *asciiz = "hello";
        string
            first = "first",
            second;

        second = first + asciiz;    // compiles ok
        second = asciiz + first;    // won't compile
    }
            
</pre>

        <li ><code>object[string::size_type pos]</code>. The subscript-operator may be used to
assign individual characters of <code>object</code> or to retrieve these
characters. There is no range-checking. If range checking is required, use the
<code>at()</code> memberfunction, summarized below.
        <li ><code>argument1 == argument2</code>. The equality operator may be used to
compare a <code>string</code> object to another <code>string</code> or <code>char const *</code>
value. The operator <code>!=</code> is available as well. The returnvalue is a
<code>bool</code>, which is <code>true</code> if the two strings are equal (i.e., contain the
same characters). <code>!=</code> returns <code>false</code> in that case.
        <li ><code>argument1 &lt; argument2</code>. The less-than operator may be used to
compare the ordering within the Ascii-character set of <code>argument1</code> and
<code>argument2</code>. The operators <code>&lt;=, &gt;</code> and <code>&gt;=</code> are available as well.
        <li ><code>ostream stream; stream &lt;&lt; argument</code>. The
insertion-operator may be used with <code>string</code> objects.
        <li ><code>istream stream; stream &gt;&gt; object</code>. The extraction-operator may be
used with <code>string</code> objects. It operates analogously to the extraction of
characters into a character array, but <code>object</code> is automatically resized
to the required number of characters.
         </ul>

        See section <a href="cplusplus10.html#ITERATORS">10.1</a> for details about <em>iterators</em>).
        <ul>
        <li > Forward iterators:
            <ul>
            <li ><code>begin()</code>
            <li ><code>end()</code>
             </ul>
        <li > Reverse iterators:
            <ul>
            <li ><code>rbegin()</code>
            <li ><code>rend()</code>
             </ul>
         </ul>

        <ul>
        <li ><code>string object</code>: Initializes <code>object</code> to an empty string.
        <li ><code>string object(string::size_type n, char c)</code>: Initializes <code>object</code> with
<code>n</code> characters <code>c</code>.
        <li ><code>string object(string argument)</code>: Initializes <code>object</code> with
<code>argument</code>.
        <li ><code>string object(string argument, string::size_type idx, string::size_type n =
pos)</code>: Initializes <code>object</code> with <code>argument</code>, using <code>n</code> characters of
<code>argument</code>, starting at index <code>idx</code>.
        <li ><code>string object(InputIterator begin, InputIterator end)</code>:
Initializes <code>object</code> with the range of characters implied by the provided
<code>InputIterators</code>.
         </ul> 


<p><br><a name="l41"></a>
<h2>3.4: Data hiding: public, private and class</h2>
    <a name="first/public"></a>
    
As mentioned previously (see section <a href="cplusplus02.html#Pretensions">2.3</a>), <strong>C++</strong>
contains special syntactical possibilities to implement data hiding. Data
hiding is the ability of one program part to hide its data from other parts;
thus avoiding improper addressing or name collisions of data.
<p><br><strong>C++</strong> has two special keywords which are concerned with data hiding:
<code>private</code> and <code>public</code>. These keywords can be inserted in the definition
of a <code>struct</code>. The keyword <code>public</code> defines all subsequent fields of a
structure as accessible by all code; the keyword <code>private</code> defines all
subsequent fields as only accessible by the code which is part of the
<code>struct</code> (i.e., only accessible for the member functions) (Besides
<code>public</code> and <code>private</code>, <strong>C++</strong> defines the keyword <code>protected</code>.
This keyword is not often used and it is left for the reader to
explore.). In a <code>struct</code> all fields are <code>public</code>, unless
explicitly stated otherwise.
<p><br>With this knowledge we can expand the <code>struct</code> <code>person</code>:
<p><br><pre>

    struct person
    {
        public:
            void
                setname (char const *n),
                setaddress (char const *a),
                print (void);
            char const
                *getname (void),
                *getaddress (void);
        private:
            char
                name [80],
                address [80];
    };

</pre>

<p><br>The data fields <code>name</code> and <code>address</code> are only accessible for the member
functions which are defined in the <code>struct</code>: these are the functions
<code>setname()</code>, <code>setaddress()</code> etc.. This property of the data type is
given by the fact that the fields <code>name</code> and <code>address</code> are preceded by
the keyword <code>private</code>. As an illustration consider the following code
fragment:
<p><br><pre>

    person
        x;

    x.setname ("Frank");        // ok, setname() is public
    strcpy (x.name, "Knarf");   // error, name is private

</pre>

<p><br>The concept of data hiding is realized here in the following manner. The
actual data of a <code>struct</code> <code>person</code> are named only in the structure
definition. The data are accessed by the outside world by special functions,
which are also part of the definition. These member functions control all
traffic between the data fields and other parts of the program and are
therefore also called `interface' functions.
The data hiding which is thus realized is illustrated further in 
figure <a href="cplusplus03.html#datahiding">2</a>.
<p><br><a name="datahiding"></a><p><center><img src="images/datahiding.gif" align="bottom" alt="figure 2 is shown here."><br> 
figure 2: Private data and public interface functions of the class Person. 
</center><p><br>
    
<p><br>Also note that the functions <code>setname()</code> and <code>setaddress()</code> are declared
as having a <code>char const *</code> argument. This means that the
functions will not alter the strings which are supplied as their arguments.
In the same vein, the functions <code>getname()</code> and <code>getaddress()</code> return a
<code>char const *</code>: the caller may not modify the strings which are
pointed to by the return values.
<p><br>Two examples of member functions of the <code>struct</code> <code>person</code> are shown
below:
<p><br><pre>

    void person::setname(char const *n)
    {
        strncpy(name, n, 79);
        name[79] = '\0';
    }

    char const *person::getname()
    {
        return (name);
    }

</pre>

<p><br>In general, the power of the member functions and of the concept of data
hiding lies in the fact that the interface functions can perform special
tasks, e.g.,  checks for the validity of data. In the above example
<code>setname()</code> copies only up to 79 characters from its argument to the data
member <code>name</code>, thereby avoiding array boundary overflow.
<p><br>Another example of the concept of data hiding is the following. As an
alternative to member functions which keep their data in memory (as do the
above code examples), a runtime library could be developed with interface
functions which store their data on file. The conversion of a program which
stores <code>person</code> structures in memory to one that stores the data on disk
would mean the relinking of the program with a different library.
<p><br>Though data hiding can be realized with <code>structs</code>, more often (almost
always) classes are used instead. A <code>class</code> is in principle equivalent to a
<code>struct</code> except that unless specified otherwise, all members (data or
functions) are <code>private</code>. As far as <code>private</code> and <code>public</code> are
concerned, a <code>class</code> is therefore the opposite of a <code>struct</code>. The
definition of a <code>class</code> <code>person</code> would therefore look exactly as shown
above, except for the fact that instead of the keyword <code>struct</code>, <code>class</code>
would be used. Our typographic suggestion for class names is a capital as
first character, followed by the remainder of the name in lower case (e.g.,
<code>Person</code>).
<p><br>
<p><br><a name="l42"></a>
<h2>3.5: Structs in C vs. structs in C++</h2>
    <a name="first/cvscpp"></a>
    At the end of this chapter we would like to illustrate the analogy between
<strong>C</strong> and <strong>C++</strong> as far as <code>struct</code>s are concerned. In <strong>C</strong> it is 
common to define several functions to process a <code>struct</code>, which then
require a pointer to the <code>struct</code> as one of their arguments. A fragment
of an imaginary <strong>C</strong> header file is given below:
<p><br><pre>

    // definition of a struct PERSON_ 
    typedef struct
    {
        char
            name[80],
            address[80];
    } PERSON_;

    // some functions to manipulate PERSON_ structs 

    // initialize fields with a name and address 
    extern void initialize(PERSON_ *p, char const *nm,
                           char const *adr);

    // print information 
    extern void print(PERSON_ const *p);

    // etc.. 

</pre>

<p><br>In <strong>C++</strong>, the declarations of the involved functions are placed inside the
definition of the <code>struct</code> or <code>class</code>. The argument which denotes which
<code>struct</code> is involved is no longer needed.
<p><br><pre>

    class Person
    {
        public:
            void initialize(char const *nm, char const *adr);
            void print(void);
            // etc..
        private:
            char 
                name[80], 
                address[80];
    };

</pre>

<p><br>The <code>struct</code> argument is implicit in <strong>C++</strong>. A function call in <strong>C</strong>
like
<p><br><pre>

    PERSON_
        x;

    initialize(&amp;x, "some name", "some address");

</pre>

<p><br>becomes in <strong>C++</strong>:
<p><br><pre>

    Person
        x;

    x.initialize("some name", "some address");

</pre>

<p><br>
<p><br><a name="Namespaces"></a><a name="l43"></a>
<h2>3.6: Namespaces</h2>
    <a name="namespace/intro"></a>
    Imagine a math teacher who wants to develop an interactive math program. For
this program functions like <code>cos(), sin(), tan()</code> etc. are to be used
accepting arguments in degrees rather than arguments in
radials. Unfortunately, the functionname <code>cos()</code> is already in use, and that
function accepts radials as its arguments, rather than degrees. 
<p><br>Problems like these are normally solved by looking for another name, e.g., the
functionname <code>cosDegrees()</code> is defined. <strong>C++</strong> offers an alternative
solution by allowing <em>namespaces</em> to be defined: areas or regions in the
code in which identifiers are defined which cannot conflict with existing
names defined elsewhere.

<p><br><a name="l44"></a>
<h3>3.6.1: Defining namespaces</h3>
        <a name="namespace/defining"></a>
    Namespaces are defined according to the following syntax:
        <pre>

    namespace identifier
    {
        // declared or defined entities
        // (declarative region)
    }
        
</pre>

    The identifier used in the definition of a namespace is a standard <strong>C++</strong>
identifier. 
<p><br>Within the <em>declarative region</em>, introduced in the above code example,
functions, variables, structs, classes and even (nested) namespaces can be
defined or declared. Namespaces cannot be defined within a block. So it is not
possible to define a namespace within, e.g., a function. However, it is
possible to define a namespace using multiple <em>namespace</em>
declarations. Namespaces are said to be <em>open</em>. This means that a namespace
<code>CppAnnotations</code> could be defined in a file <code>file1.cc</code> and also in a file
<code>file2.cc</code>. The entities defined in the <code>CppAnnotations</code> namespace of
files <code>file1.cc</code> and <code>file2.cc</code> are then united in one <code>CppAnnotations</code>
namespace region. For example:
        <pre>

    // in file1.cc
    namespace CppAnnotations
    {
        double cos(double argInDegrees)
        {
            ...
        }
    }

    // in file2.cc
    namespace CppAnnotations
    {
        double sin(double argInDegrees)
        {
            ...
        }
    }
        
</pre>

    Both <code>sin()</code> and <code>cos()</code> are now defined in the same
<code>CppAnnotations</code> namespace. 
<p><br>Namespace entities can also be defined outside of their namespaces. This
topic is discussed in section <a href="cplusplus03.html#OUTSIDE">3.6.4.1</a>.

<p><br>
<a name="l45"></a>

             
<strong>3.6.1.1: Declaring entities in namespaces</strong><p>
            <a name="namespace/declaring"></a>
        Instead of <em>defiing</em> entities in a namespace, entities may also be
<em>declared</em> in a namespace. This allows us to put all the declarations of a
namespace in a header file which can thereupon be included in sources in which
the entities of a namespace are used. Such a header file could contain, e.g.,
        <pre>

    namespace CppAnnotations
    {
        double cos(double degrees);
        double sin(double degrees);
    }
        
</pre>

<p><br>
<p><br>
<a name="l46"></a>

             
<strong>3.6.1.2: A closed namespace</strong><p>
            <a name="namespace/closed"></a>
    Namespaces can be defined without using a name. Such a namespace is anonymous
and it restricts the usability of the defined entities to the source file in
which the anonymous namespace is defined. 
<p><br>The entities that are defined in the anonymous namespace are accessible the
same way as <code>static</code> functions and variables in <strong>C</strong>. The <code>static</code>
keyword can still be used in <strong>C++</strong>, but its use is more dominant in
<code>class</code> definitions (see chapter <a href="cplusplus04.html#Classes">4</a>). In situations where static
variables or functions are necessary, the use of the anonymous namespace is
preferred. 

<p><br><a name="l47"></a>
<h3>3.6.2: Referring to entities</h3>
        <a name="namespace/referring"></a>
    Given a namespace and entities that are defined or declared in it, the scope
resolution operator can be used to refer to the entities that are defined in
the namespace. For example, to use the function <code>cos()</code> defined in the
<code>CppAnnotations</code> namespace the following code could be used:
        <pre>

    // assume the CppAnnotations namespace is declared in the next header
    // file:
    #include &lt;CppAnnotations&gt;
    
    int main()
    {
        cout &lt;&lt; "The cosine of 60 degrees is: " &lt;&lt;
                CppAnnotations::cos(60) &lt;&lt; endl;
        return (0);
    }
        
</pre>

    This is a rather cumbersome way to refer to the <code>cos()</code> function in the
<code>CppAnnotations</code> namespace, especially so if the function is frequently
used. 
<p><br>Therefore, an <em>abbreviated</em> form (just <code>cos()</code> can be used by
declaring that <code>cos()</code> will refer to <code>CppAnnotations::cos()</code>. For this,
the <code>using</code>-declaration can be used. Following
        <pre>

    using CppAnnotations::cos;      // note: no function prototype, just the
                                    // name of the entity is required.    
        
</pre>

    the function <code>cos()</code> will refer to the <code>cos()</code> function in the
<code>CppAnnotations</code> namespace. This implies that the standard <code>cos()</code>
function, accepting radials, cannot be used automatically anymore. The plain
scope resolution operator can be used to reach the generic <code>cos()</code> function:
        <pre>

    int main()
    {
        using CppAnnotations::cos;
        ...
        cout &lt;&lt; cos(60)         // this uses CppAnnotations::cos()
            &lt;&lt; ::cos(1.5)       // this uses the standard cos() function
            &lt;&lt; endl;
        return (0);
    }
        
</pre>

    Note that a <code>using</code>-declaration can be used inside a block. The
<code>using</code> declaration prevents the definition of entities having the same
name as the one used in the <code>using</code> declaration: it is not possible to
use a using declaration for a variable <code>value</code> in the <code>CppAnnotations</code>
namespace, and to define (or declare) an identically named object in the
block in which the <code>using</code> declaration was placed:
        <pre>

    int main()
    {
        using CppAnnotations::value;
        ...
        cout &lt;&lt; value &lt;&lt; endl;  // this uses CppAnnotations::value

        int
            value;              // error: value already defined.

        return (0);
    }
        
</pre>
    
<p><br>
<p><br>
<a name="l48"></a>

             
<strong>3.6.2.1: The using directive</strong><p>
            <a name="namespace/directive"></a>
    A generalized alternative to the <code>using</code>-declaration is the
<code>using</code>-<em>directive</em>: 
        <pre>

    using namespace CppAnnotations;
        
</pre>

    Following this directive, <em>all</em> entities defined in the
<code>CppAnnotations</code> namespace are uses as if they where declared by <code>using</code>
declarations. 
<p><br>While the <code>using</code>-directive is a quick way to import all the names of
the <code>CppAnnotations</code> namespace (assuming the entities are declared or
defined separately from the directive), it is at the same time a somewhat
dirty way to do so, as it is less clear which entity will be used in a
particular block of code.
<p><br>If, e.g., <code>cos()</code> is defined in the <code>CppAnnotations</code> namespace, the
function <code>CppAnnotations::cos()</code> will be used when <code>cos()</code> is called in
the code. However, if <code>cos()</code> is <em>not</em> defined in the <code>CppAnnotations</code>
namespace, the standard <code>cos()</code> function will be used. The <code>using</code>
directive does not document as clearly which entity will be used as the
<code>using</code> declaration does. For this reason, the <code>unsing</code> directive is
somewhat deprecated.

<p><br><a name="l49"></a>
<h3>3.6.3: The standard namespace</h3>
        <a name="namespace/std"></a>
    Apart from the anonymous namespace, many entities of the runtime available
software (e.g., <code>cout, cin, cerr</code> and the templates defined in the
<em>Standard Template Library</em>, see chapter <a href="cplusplus10.html#STL">10</a>) are now defined in the
<code>std</code> namespace.
<p><br>Regarding the discussion in the previous section, one should use a <code>using</code>
declaration for these entities. For example, in order to use the <code>cout</code>
stream, the code should start with something like
        <pre>

    #include &lt;iostream&gt;
    
    using std::cout;
        
</pre>

    Often, however, the identifiers that are defined in the <code>std</code> namespace
can all be accepted without much thought. Because of that, one often
encounters a <code>using</code> directive, rather than a <code>using</code> declaration with the
<code>std</code> namespace. So, instead of the mentioned <code>using declaration</code> a
construction like
        <pre>

    #include &lt;iostream&gt;
    
    using namespace std;
        
</pre>

    is often encountered. Whether this should be encouraged is subject of some
dispute. Long <code>using</code> declarations are of course inconvenient too. So as a
rule of thumb one might decide to stick to <code>using</code> declarations, up to the
point where the list becomes impractically long, at which point a <code>using</code>
directive could be considered.
<p><br>
<p><br><a name="l50"></a>
<h3>3.6.4: Nesting namespaces and namespace aliasing</h3>
        <a name="namespace/nesting"></a>
    Namespaces can be nested. The following code shows the definition of a nested
namespace: 
        <pre>

    namespace CppAnnotations
    {
        namespace Virtual
        {
            void
                *pointer;
        }
    }
        
</pre>

    Now the variable <code>pointer</code> defined in the <code>Virtual</code> namespace, nested
under the <code>CppAnnotations</code> namespace. In order to refer to this variable,
the following options are available:
    <ul>
        <li > The <em>fully qualified name</em> can be used. A fully qualified name
of an entity is a list of all the namespaces that are visited until the
definition of the entity is reached, glued together by the scope resolution
operator:
        <pre>

    int main()
    {
        CppAnnotations::Virtual::pointer = 0;
        return (0);
    }
        
</pre>

        <li > A <code>using</code> declaration for <code>CppAnnotations::Virtual</code> can be
used. Now <code>Virtual</code> can be used without any prefix, but 
<code>pointer</code> must be used with the <code>Virtual::</code> prefix:
        <pre>

    ...
    using CppAnnotations::Virtual;

    int main()
    {
        Virtual::pointer = 0;
        return (0);
    }
        
</pre>

        <li > A <code>using</code> declaration for <code>CppAnnotations::Virtual::pointer</code>
can be used. Now <code>pointer</code> can be used without any prefix:
        <pre>

    ...
    using CppAnnotations::Virtual::pointer;

    int main()
    {
        pointer = 0;
        return (0);
    }
        
</pre>

        <li > A <code>using</code> directive or directives can be used:
        <pre>

    ...
    using namespace CppAnnotations::Virtual;

    int main()
    {
        pointer = 0;
        return (0);
    }
        
</pre>

    Alternatively, two separate <code>using</code> directives could have been used:
        <pre>

    ...
    using namespace CppAnnotations;
    using namespace Virtual;

    int main()
    {
        pointer = 0;
        return (0);
    }
        
</pre>

<p><br><li > A combination of <code>using</code> declarations) and <code>using</code>
directives can be used. E.g., a <code>using</code> directive can be used for
the <code>CppAnnotations</code> namespace, and a <code>using</code> declaration can be used for
the <code>Virtual::pointer</code> variable:
        <pre>

    ...
    using namespace CppAnnotations;
    using Virtual::pointer;

    int main()
    {
        pointer = 0;
        return (0);
    }
        
</pre>

    </ul>
    At every <code>using</code> directive all entities of that namespace can be used
without any further prefix. If a namespace is nested, then that namespace can
also be used without any further prefix. However, the entities defined in the
nested namespace still need the nested namespace's name. Only by using a
<code>using</code> declaration or directive the qualified name of the 
nested namespace can be omitted.
<p><br>When fully qualified names are somehow preferred, while the long form (like
<code>CppAnnotations::Virtual::pointer</code>) is at the same time considered too long,
a namespace <em>alias</em> can be used:
        <pre>

    namespace CV = CppAnnotations::Virtual;
        
</pre>

    This defines <code>CV</code> as an <em>alias</em> for the full name. So, to refer to the
<code>pointer</code> variable the construction
        <pre>

    CV::pointer = 0;
        
</pre>

    Of course, a namespace alias itself can also be used in a <code>using</code>
declaration or directive.
<p><br>
<p><br><a name="OUTSIDE"></a>
<a name="l51"></a>

             
<strong>3.6.4.1: Defining entities outside of their namesapces</strong><p>
            <a name="namespace/outside"></a>
    It is not strictly necessary to define members of namespaces within a
<code>namespace</code> region. By prefixing the member by its namespace or namespaces a
member can be defined outside of a namespace region. This may be done at the
global level, or at intermediate levels in the case of nested namespaces. So it
is not possible to define a member of namespace <code>A</code> within the region of
namespace <code>C</code>, but it is possible to define a member of namespace <code>A::B</code>
within the region of namespace <code>A</code>. 
<p><br>Note, however, that when a member of a namespace is defined outside of a
namespace region, it must <em>still be declared within</em> the region.
<p><br>Assume the type <code>int INT8[8]</code> is defined in the
<code>CppAnnotations::Virtual</code> namespace.
<p><br>Now suppose we want to define (at the global level) a member function
<code>funny</code> of namespace <code>CppAnnotations::Virtual</code>, returning a pointer to
<code>CppAnnotations::Virtual::INT8</code>. The definition of such a function could be
as follows (first defining everything inside the <code>CppAnnotations::Virtual</code>
namespace):
        <pre>

    namespace CppAnnotations
    {
        namespace Virtual
        {
            void
                *pointer;

            typedef int INT8[8];

            INT8 *funny()
            {
                INT8
                    *ip = new INT8[1];
                
                for (int idx = 0; idx &lt; sizeof(INT8) / sizeof(int); ++idx)
                    (*ip)[idx] = (1 + idx) * (1 + idx);

                return (ip);
            }
        }
    }
        
</pre>

    The function <code>funny()</code> defines an array of one <code>INT8</code> vector, and
returns its address after initializing the vector by the squares of the first
eight natural numbers.
<p><br>Now the function <code>funny()</code> can be defined outside of the
<code>CppAnnotations::Virtual</code> as follows:
        <pre>

    namespace CppAnnotations
    {
        namespace Virtual
        {
            void
                *pointer;

            typedef int INT8[8];

            INT8 *funny();
        }
    }

    CppAnnotations::Virtual::INT8 *CppAnnotations::Virtual::funny()
    {
        INT8
            *ip = new INT8[1];
        
        for (int idx = 0; idx &lt; sizeof(INT8) / sizeof(int); ++idx)
        {
            cout &lt;&lt; idx &lt;&lt; endl;
            (*ip)[idx] = idx * idx;
        }

        return (ip);
    }
        
</pre>

    At the final code fragment note the following:
    <ul>
    <li ><code>funny()</code> is declared inside of the <code>CppAnnotations::Virtual</code>
namespace. 
    <li ><code></code> The definition outside of the namespace region requires us to use
the fully qualified name of the function <em>and</em> of its returntype.
    <li ><code></code> <em>Inside</em> the block of the function <code>funny</code> we are within the
<code>CppAnnotations::Virtual</code> namespace, so inside the function fully
qualified names (e.g., for <code>INT8</code> are not required any more.
    </ul>
<p><br>Finally, note that the function could also have been defined in the
<code>CppAnnotations</code> region. It that case the <code>Virtual</code> namespace would have
been required for the function name and its returntype, while the internals of
the function would remain the same:
        <pre>

    namespace CppAnnotations
    {
        namespace Virtual
        {
            void
                *pointer;

            typedef int INT8[8];

            INT8 *funny();
        }

        Virtual::INT8 *Virtual::funny()
        {
            INT8
                *ip = new INT8[1];
            
            for (int idx = 0; idx &lt; sizeof(INT8) / sizeof(int); ++idx)
            {
                cout &lt;&lt; idx &lt;&lt; endl;
                (*ip)[idx] = idx * idx;
            }
    
            return (ip);
        }
    }
        
</pre>

<p><br>
<p><br>
<p><br>


<hr>
<ul>
    <li> <a href="cplusplus04.html">Next chapter</a>
    <li> <a href="cplusplus02.html">Previous chapter</a>
    <li> <a href="cplusplus.html">Table of contents</a>
</ul>
<hr>
</body>
</html>
