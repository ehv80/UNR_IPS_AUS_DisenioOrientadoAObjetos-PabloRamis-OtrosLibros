<html>
<head>
<title>C++ Annotations
        Version 4.4.0k </title>
</head>
<body fgcolor="black" bgcolor="white"  >
<hr>
<ul>
    <li> <a href="cplusplus07.html">Next chapter</a>
    <li> <a href="cplusplus05.html">Previous chapter</a>
    <li> <a href="cplusplus.html">Table of contents</a>
</ul>
<hr>

<a name="OperatorOverloading"></a><a name="l89"></a>
<h1>Chapter 6: More About Operator Overloading</h1>
<a name="overload"></a>
    

<blockquote>
    <em>
        We're always interested in getting feedback. E-mail us if you like
        this guide, if you think that important material is omitted, if you
        encounter errors in the code examples or in the documentation, if you
        find any typos, or generally just if you feel like e-mailing. Mail to
        <a href="http://www.icce.rug.nl/frank/">Frank Brokken</a>
        or use an
        <a href="http://www.icce.rug.nl/frank/efrank.html">e-mail form</a>.
        Please state the concerned document version, found in
        the title. 
    </em>
</blockquote>
<p><br>
<p><br><a name="overload/more"></a>
    Now that we've covered the overloaded assignment operator in depth, and
now that we've seen some examples of other overloaded operators as well
(i.e., the insertion and extraction operators), let's take a look at some
other interesting examples of  operator overloading.
     
<p><br><a name="l90"></a>
<h2>6.1: Overloading operator[]()</h2>
<a name="overload/array"></a>
    As our next example of operator overloading, we present a class which is
meant to operate on an array of <code>int</code>s. Indexing the array elements occurs
with the standard array operator <code>[]</code>, but additionally the class checks
for boundary overflow. Furthermore, the array operator is interesting in that 
it both <em>produces</em> a value and <em>accepts</em> a value, when used, respectively, 
as a <em>right-hand value</em> and a <em>left-hand value</em> in expressions.
<p><br>An example of the use of the class is given here:
<pre>

    int main()
    {
        IntArray
            x(20);              // 20 ints

        for (int i = 0; i &lt; 20; i++)
            x[i] = i * 2;       // assign the elements
                   
                                // produces boundary
                                // overflow
        for (int i = 0; i &lt;= 20; i++)
            cout &lt;&lt; "At index " &lt;&lt; i &lt;&lt; ": value is " &lt;&lt; x[i] &lt;&lt; endl;

        return (0);
    }

</pre>

This example shows how an array is created to contain 20 <code>int</code>s. The elements
of the array can be assigned or retrieved. The above example should produce a
run-time error, generated by the class <code>IntArray</code>: the last
<code>for</code> loop causing a boundary overflow, since <code>x[20]</code> is addressed while
legal indices range from 0 to 19, inclusive.
<p><br>We give the following class interface:
<pre>
    class IntArray
    {
         public:
            IntArray(int size = 1);     // default size: 1 int
            IntArray(IntArray const &amp;other);
            ~IntArray();
            IntArray const &amp;operator=(IntArray const &amp;other);

                            // overloaded index operators:
            int &amp;operator[](int index);         // first
            int operator[](int index) const;    // second
        private:
            void boundary(int index) const;
            void destroy();             // standard functions
                                        // used to copy/destroy
            void copy(IntArray const &amp;other);

            int 
                *data, 
                size;
    };

    #include &lt;iostream&gt;
</pre>

<p><br>Concerning this class interface we remark:
<p><br><ul>
<p><br><li > The class has a constructor with a default <code>int</code> argument,
    specifying the array size. This function serves also as the default
    constructor, since the compiler will substitute 1 for the argument when
    none is given.
<p><br><li > The class internally uses a pointer to reach allocated memory.
    Hence, the necessary tools are provided: a copy constructor, an overloaded
    assignment function and a destructor.
<p><br><li > Note that there are two overloaded index operators. Why are there
    two of them ?
<p><br>The first overloaded index operator allows us to reach and obtain 
    the elements of the <code>IntArray</code> object.
<p><br>This overloaded operator has as its prototype a function that
    returns <em>a reference</em> to
    an <code>int</code>. This allows us to use expressions like <code>x[10]</code> 
    on the left-hand side <em>and</em> on the right-hand side of an assignment. 
<p><br>We can
    therefore use the same function to retrieve and to assign values.
    Furthermore note that the returnvalue of the overloaded array operator is
    <em>not</em> a <code>int const &amp;</code>, but rather a <code>int &amp;</code>. In this situation we
    don't want the <code>const</code>, as we must be able to change the element
    we want to access, if the operator is used as a left-hand value in an 
    assignment.
<p><br>However, this whole scheme fails if there's nothing to assign. Consider
the situation where we have an <code>IntArray const stable(5);</code>. Such an object
is a <em>const</em> object, which cannot be modified. The compiler detects this and
will refuse to compile this object definition if only the first overloaded
index operator is available. Hence the second overloaded index operator. Here
the return-value is an <code>int</code>, rather than an <code>int &amp;</code>, and the
member-function itself is a <code>const</code> member function. This second form 
of the overloaded index operator cannot be used with <em>non-</em><code>const</code>
objects, but it's perfect for <code>const</code> objects. It can only be used for
value-retrieval, not for value-assignment, but that is precisely what we want
with <code>const</code> objects. 
<p><br><li > We used the standard implementations of the copy constructor,
    the overloaded assignment operator and the destructor, discussed before
    (in section <a href="cplusplus05.html#CopyDestroy">5.4.1</a>), albeit that we've left out the 
    implementation of the function <code>destroy()</code>, as this function would
    consist of merely one statement (<code>delete data</code>). 
<p><br><li > As the elements of <code>data</code> are <code>int</code>s, no <code>delete []</code> is needed.
    It does no harm, either. Therefore, since we use the <code>[]</code> when the
    object is created, we also use the <code>[]</code> when the data are eventually
    destroyed.
<p><br></ul>
<p><br>The member functions of the class are presented next.
<pre>
    #include "intarray.h"

    IntArray::IntArray(int sz)
    {
        if (sz &lt; 1)
        {
            cerr &lt;&lt; "IntArray: size of array must be &gt;= 1, not " &lt;&lt; sz
                 &lt;&lt; "!" &lt;&lt; endl;
            exit(1);
        }
        // remember size, create array
        size = sz;
        data = new int [sz];
    }

    // copy constructor
    IntArray::IntArray(IntArray const &amp;other)
    {    
        copy(other);
    }
    
    // destructor
    IntArray::~IntArray()
    {    
        delete [] data;
    }
    
    // overloaded assignment
    IntArray const &amp;IntArray::operator=(IntArray const &amp;other)
    {
        // take action only when no auto-assignment
        if (this != &amp;other)
        {
            delete [] data;
            copy(other);
        }
        return (*this);
    }

    // copy() primitive
    void IntArray::copy(IntArray const &amp;other)
    {
        // set size
        size = other.size;

        // create array
        data = new int [size];

        // copy other's values
        for (register int i = 0; i &lt; size; i++)
            data[i] = other.data[i];
    }

    // here is the first overloaded array operator
    int &amp;IntArray::operator[](int index)
    {
        boundary(index);
        return (data[index]);   // emit the reference
    }

    // and the second overloaded array operator
    int IntArray::operator[](int index) const
    {
        boundary(index);
        return (data[index]);   // emit the value
    }

    // the function checking the boundaries for the index:
    void IntArray::boundary(int index) const
    {
        // check for array boundary over/underflow
        if (index &lt; 0 || index &gt;= size)
        {
            cerr &lt;&lt; "IntArray: boundary overflow or underflow, index = " 
                 &lt;&lt; index &lt;&lt; ", should range from 0 to " &lt;&lt; size - 1 &lt;&lt; endl;
            exit(1);
        }
    }
</pre>

<p><br>
<p><br><a name="l91"></a>
<h2>6.2: Overloading operator new(size_t)</h2>
<a name="overload/new"></a>
    
If the <code>operator new</code> is overloaded, it must have a <code>void *</code> return type,
and at least an argument of type <code>size_t</code>. The <code>size_t</code> type is defined in
<code>stddef.h</code>, which must therefore be included when the operator <code>new</code>
is overloaded.
<p><br>It is also possible to define multiple versions of the <code>operator new</code>, as 
long as each version has its own unique set of arguments. The global <code>new</code>
operator can still be used, through the <code>::</code>-operator. If a class <code>X</code>
overloads the operator <code>new</code>, then the system-provided operator <code>new</code> is
activated by 
                        <center><code>X *x = ::new X();</code> </center>    
<p><br>Furthermore, the <code>new []</code> construction will always use the default operator
<code>new</code>. 
<p><br>An example of the overloaded operator <code>new</code> for the class <code>X</code> is the 
following:
<pre>
                        
    #include &lt;stddef.h&gt;

    void *X::operator new(size_t sizeofX)
    {
        void
            *p = new char[sizeofX];
            
        return (memset(p, 0, sizeof(X)));
    } 

</pre>
 
<p><br>Now, what happens when the operator <code>new</code> is defined for the <code>class X</code>,
assuming that class is defined as follows (For the sake of simplicity
    we have violated the principle of encapsulation here. The principle of
    encapsulation, however, is immaterial to the discussion of the workings of 
    the operator <code>new</code>.):
<pre>

    class X
    {
        public:
            void *operator new(size_t sizeofX);

            int
                x,
                y,
                z;
    };

</pre>

<p><br>Next, consider the following program fragment:
<pre>

    #include "X.h"  // class X interface etc.
    
    int main()
    {
        X
            *x = new X();
            
        cout &lt;&lt; x-&gt;x &lt;&lt; ", " &lt;&lt; x-&gt;y &lt;&lt; ", "&lt;&lt; x-&gt;z &lt;&lt; endl;
        return (0);
    }

</pre>

<p><br>This small program produces the following output:
    <center><code>0, 0, 0</code> </center>
<p><br>Our little program performed the following actions:
<ul>
    <li > First, operator new was called, which allocated and initialized
        a block of memory, the size of an <code>X</code> object.
    <li > Next, a pointer to this block of memory was passed to the
        (default) <code>X()</code> constructor. Since no constructor was defined, 
        the constructor itself didn't do anything at all.
</ul>
Due to the initialization of the block of memory by the <code>new</code> operator
the allocated <code>X</code> object was already initialized to zeros when the 
constructor was called. 
<p><br>Non-static object member functions are passed a (hidden) pointer to the object
on which they should operate. This hidden pointer becomes the <code>this</code> pointer
inside the memberfunction. This procedure is also followed by the constructor.
In the following fragments of pseudo <strong>C++</strong> 
the pointer is made visible. In the first
part an <code>X</code> object is declared directly, in the second part of the example
the (overloaded) operator <code>new</code> is used:
<pre>

        X::X(&amp;x);   // x's address is passed to the constructor
                    // the compiler made 'x' available

        void        // ask new to allocate the memory for an X
            *ptr = X::operator new();
        X::X(ptr);  // and let the constructor operate on the
                    // memory returned by 'operator new'

</pre>

Notice that in the pseudo <code>C++</code> fragment the member functions were treated
as static functions of the class <code>X</code>. Actually, the <code>operator new()</code> 
operator <em>is</em> a static functions of its class: it cannot reach data members
of its object, since it's normally the task of the <code>operator new()</code> to create 
room for that object first. It can do that by allocating enough memory, and
by initializing the area as required. Next, the memory is passed over to the
constructor (as the <code>this</code> pointer) for further processing. The fact that
an overloaded operator <code>new</code> is in fact a static function, not requiring
an object of its class can be illustrated in the following (discouraged
in normal situations !) program fragment, which can be compiled without 
problems (assume <code>class X</code> has been defined and is available as before):
<pre>

    int main()
    {
        X
            x;

        X::operator new(sizeof x);

        return (0);
    }

</pre>
 
The call to <code>X::operator new()</code> returns a <code>void *</code> to an initialized block
of memory, the size of an <code>X</code> object.
<p><br>The operator <code>new</code> can have multiple parameters. The first parameter again
is the <code>size_t</code> parameter, other parameters must be passed during the
call to the <code>operator new</code>. For example:
<pre>

    class X
    {
        public:
            void *operator new(size_t p1, unsigned p2);
            void *operator new(size_t p1, char const *fmt, ...);
    };
    
    int main()
    {
        X
            *object1 = new(12) X(),
            *object2 = new("%d %d", 12, 13) X(),
            *object3 = new("%d", 12) X();

        return (0);
    }

</pre>

The object (object1) is a pointer to an <code>X</code> object for which the memory has
been allocated by the call to the first overloaded <code>operator new</code>, followed
by the call of the constructor <code>X()</code> for that block of memory. 
The object (object2) is a pointer to an <code>X</code> object for which the memory has
been allocated by the call to the second overloaded <code>operator new</code>, followed
again by a call of the constructor <code>X()</code> for its block of memory. 
Notice that <code>object3</code> also uses the second overloaded <code>operator new()</code>:
that overloaded operator accepts a variable number of arguments, the first
of which is a <code>char const *</code>.
<p><br>
<p><br><a name="l92"></a>
<h2>6.3: Overloading operator delete(void *)</h2>
<a name="overload/delete"></a>
    The <code>delete</code> operator may be overloaded too. The <code>operator delete</code> must 
have a <code>void *</code> argument, and an optional second argument of type <code>size_t</code>,
which is the size in bytes of objects of the class for which the <code>operator
delete</code> is overloaded. The returntype of the overloaded <code>operator delete</code> is
void. 
<p><br>Therefore, in a class the operator <code>delete</code> may be overloaded using the
following prototype:
<p><br><center><code>void operator delete(void *);</code> </center>
<p><br>or
<p><br><center><code>void operator delete(void *, size_t);</code> </center>
<p><br>The `home-made' <code>delete</code> operator is called after executing the class' 
destructor. So, the statement
<p><br><center><code>delete ptr;</code> </center>
<p><br>with <code>ptr</code> being a pointer to an object of the class <code>X</code> for which the 
operator <code>delete</code> was overloaded, boils down to the following statements:
<p><br><pre>

    X::~X(ptr);     // call the destructor function itself

                    // and do things with the memory pointed
                    // to by ptr itself.
    X::operator delete(ptr, sizeof(*ptr));

</pre>

<p><br>The overloaded operator <code>delete</code> may do whatever it wants to do with the
memory pointed to by <code>ptr</code>. It could, e.g., simply delete it. If that
would be the preferred thing to do, then the default <code>delete</code> operator
can be activated using the <code>::</code> scope resolution operator. For example:
<p><br><pre>

    void X::operator delete(void *ptr)
    {
        // ... whatever else is considered necessary
                     
        // use the default operator delete 
        ::delete ptr;
    }

</pre>
                                   

<p><br><a name="CoutOperators"></a><a name="l93"></a>
<h2>6.4: Cin, cout, cerr and their operators</h2>
<a name="overload/cin"></a>
    This section describes how a class can be adapted in such a way that it
can be used with the
<code>C++</code> streams <code>cout</code> and <code>cerr</code> and the insertion operator
<code>&lt;&lt;</code>. Adaptation of a class for the usage with <code>cin</code> and
its extraction operator <code>&gt;&gt;</code> occurs in a similar way and is not illustrated
here.
<p><br>The implementation of an overloaded operator <code>&lt;&lt;</code> in the context
of <code>cout</code> or <code>cerr</code> involves the base class of <code>cout</code> or
<code>cerr</code>, which is <code>ostream</code>. This class is declared in the header
file <code>iostream</code> and defines only overloaded operator functions for
`basic' types, such as, <code>int</code>, <code>char*</code>, etc.. The purpose of
this section is to show how an operator function can be defined which
processes a new class, say <code>Person</code> (see chapter <a href="cplusplus05.html#Person">5.1</a>) ,
so that constructions as the following one become possible:
<p><br><pre>

    Person
        kr("Kernighan and Ritchie", "unknown", "unknown");

    cout &lt;&lt; "Name, address and phone number of Person kr:\n"
         &lt;&lt; kr
         &lt;&lt; '\n';

</pre>
        
<p><br>The statement <code>cout &lt;&lt; kr</code> involves the operator <code>&lt;&lt;</code>
and its two operands: an <code>ostream &amp;</code> and a <code>Person &amp;</code>. The
proposed action is defined in a class-less operator function
<code>operator&lt;&lt;()</code> expecting two arguments:
<p><br><pre>

    // declaration in, say, person.h
    ostream &amp;operator&lt;&lt;(ostream &amp;, Person const &amp;);

    // definition in some source file
    ostream &amp;operator&lt;&lt;(ostream &amp;stream, Person const &amp;pers)
    {
        return 
        (
            stream &lt;&lt; "Name:    " &lt;&lt; pers.getname()
                   &lt;&lt; "Address: " &lt;&lt; pers.getaddress()
                   &lt;&lt; "Phone:   " &lt;&lt; pers.getphone()
        );
    }

</pre>
    
<p><br>Concerning this function we remark the following:
<p><br><ul>
<p><br><li > The function must return a (reference to) <code>ostream</code> object,
    to enable `chaining' of the operator.
<p><br><li > The two operands of the operator <code>&lt;&lt;</code> are stated as
    the two arguments of the overloading function.
<p><br><li > The class <code>ostream</code> provides the member function
    <code>opfx()</code>, which flushes any other <code>ostream</code> streams tied
    with the current stream. <code>opfx()</code> returns 0 when an error has been
    encountered (Cf. chapter <a href="cplusplus11.html#iostreams">11</a>).
<p><br>An improved form of the above function would therefore be:
<p><br><pre>

    ostream &amp;operator&lt;&lt;(ostream &amp;stream, Person const &amp;pers)
    {
        if (! stream.opfx())
            return (stream);
        ...
    }

</pre>
    
<p><br></ul>
<p><br>
<p><br><a name="ConversionOperators"></a><a name="l94"></a>
<h2>6.5: Conversion operators</h2>
<a name="overload/conversion"></a>
    A class may be constructed around a basic type. E.g., it is often fruitful
to define a class <code>String</code> around the <code>char *</code>. Such a class may define all
kinds of operations, like assignments. Take a look at the following
class interface:
<pre>

class String
{
    public:
        String();
        String(char const *arg);
        ~String();            
        String(String const &amp;other);
        String const &amp;operator=(String const &amp;rvalue);
        String const &amp;operator=(char const *rvalue);
    private:
        char
            *string;
};

</pre>

Objects from this class can be initialized from a 
<code>char const *</code>, and 
also from a <code>String</code> itself. There is an overloaded assignment operator,
allowing the assignment from a <code>String</code> object and from a 
<code>char const *</code> (Note that the assingment from a <code>char const *</code>
also includes the null-pointer. An assignment like <code>stringObject = 0</code> is
perfectly in order.).
<p><br>Usually, in classes that are less directly linked to their data than this 
<code>String</code> class, there will be an accessor member function, like 
<code>char const *String::getstr() const</code>. However, in the current context that
looks a bit awkward, but it <em>also</em> doesn't seem to be the right way to
go when an array of strings is defined, e.g., in a class <code>StringArray</code>,
in which the <code>operator[]</code> is implemented to allow the access of individual
strings. Take a look at the following class interface:
<pre>

class StringArray
{
    public:
        StringArray(unsigned size);
        StringArray(StringArray const &amp;other);
        StringArray const &amp;operator=(StringArray const &amp;rvalue);
        ~StringArray();            

        String &amp;operator[](unsigned index);
    private:
        String
            *store;
        unsigned
            n;
};

</pre>

<p><br>The <code>StringArray</code> class has one interesting memberfunction: the overloaded
array operator <code>operator[]</code>. It returns a <code>String</code> reference. 
<p><br>Using this operator assignments between the <code>String</code> elements can be 
realized:
<pre>

    StringArray
        sa(10);             
        
    ... // assume the array is filled here
    
    sa[4] = sa[3];  // String to String assignment

</pre>

<p><br>It is also possible to assign a <code>char const *</code> to an element of <code>sa</code>:
    <center><code>sa[3] = "hello world";</code> </center>
When this is evaluated, the following steps are followed:
<ul>
    <li > First, <code>sa[3]</code> is evaluated. This results in a <code>String</code> reference.
    <li > Next, the <code>String</code> class is inspected for an overloaded assignment,
        expecting a <code>char const *</code> to its right-hand side. This operator is
        found, and the string object <code>sa[3]</code> can receive its new value.
</ul>
<p><br>Now we try to do it the other way around: how to <em>access</em> the 
<code>char const *</code> that's stored in <code>sa[3]</code>? We try the following code:
<pre>

    char const
        *cp;
        
    cp = sa[3];

</pre>
              
Well, this won't work: we would need an overloaded assignment operator for the 
'class char const *'. However, there isn't such a class, and therefore we 
can't build that overloaded assignment operator (see also section 
<a href="cplusplus06.html#OverloadableOperators">6.9</a>). Furthermore, <em>casting</em> won't work: the
compiler doesn't know how to cast a <code>String</code> to a <code>char const *</code>.
How to proceed?
<p><br>The naive solution is to resort to the accessor member function <code>getstr()</code>:
    <center><code>cp = sa[3].getstr();</code> </center>
That solution would work, but it looks so clumsy.... A far better approach
would be to a <em>conversion operator</em>.
<p><br>A <em>conversion operator</em> is a kind of overloaded operator, but this time the
overloading is used to cast the object to another type. Using a conversion
operator a <code>String</code> object may be interpreted as a <code>char const *</code>, which
can then be assigned to another <code>char const *</code>. Conversion operators can be
implemented for all types for which a conversion is needed. 
<p><br>In the current example, the <code>class String</code> would need a conversion operator
for a <code>char const *</code>. The general form of a conversion operator in the class 
interface is:
    <center><code>operator &lt;type&gt;();</code> </center>
With our <code>String</code> class, it would therefore be:
    <center><code>operator char const *();</code> </center>
<p><br>The implementation of the conversion operator is straightforward: 
<pre>

    String::operator char const *()
    {
        return (string);
    }

</pre>

<p><br>Notes:
<ul>
    <li > There is <em>no</em> mentioning of a return type. The conversion operator
        has the type of the returned value just after the <code>operator</code> keyword.
    <li > In certain situations the compiler needs a hand to disambiguate our
        intentions. In a statement like
            <center><code>printf("%s", sa[3]);</code> </center>
        the compiler is confused: are we going to pass a <code>String &amp;</code> or a 
        <code>char const *</code> to the <code>printf()</code> function? To help the compiler 
        out, we supply an explicit cast here:
            <center><code>printf("%s", (char const *)sa[3]);</code> </center>
</ul>
<p><br>For completion, the final <code>String</code> class interface,  containing the 
conversion operator, looks like this:
<pre>

class String
{
    public:
        String();
        String(char const *arg);
        ~String();            
        String(String const &amp;other);
        String const &amp;operator=(String const &amp;rvalue);
        String const &amp;operator=(char const *rvalue);
        operator char const *();
    private:
        char
            *string;
};

</pre>

<p><br>
<p><br><a name="EXPLICIT"></a><a name="l95"></a>
<h2>6.6: The `explicit' keyword</h2>
<a name="overload/explicit.yo"></a>
    Assume we have a class that's doing all kinds of interesting stuff. Its public
members could be, e.g.:
        <pre>

    class Convertor
    {
        public:
            Convertor();
            Convertor(char const *str);
            Convertor(Convertor const &amp;other);
            ~Convertor();
            operator char const*();
            void anyOtherMemberFunction();
    };
        
</pre>

    Objects of the class <code>Convertor</code> may be constructed using a default
constructor and using a <code>char const *</code>. Functions might return
<code>Convertor</code> objects and functions might expect <code>Convertor</code> objects as
arguments. E.g.,
        <pre>

    Convertor returnConvertorObject()
    {
        Convertor
            convertor;

        return (convertor);
    }
    void expectConvertorObject(Convertor const &amp;object)
    {
        ...
    }
        
</pre>

<p><br>In cases like these, <em>implicit conversions</em> to <code>Convertor</code> objects
will be performed if there are constructors having one parameter (or multiple
parameters, using default argument values), if an argument of the type of the
single parameter is passed to or returned from the function. E.g., the
following function expects a <code>char const *</code> and returns an <code>Convertor
object</code> due to the implicit conversion from <code>char const *</code> to
<code>Convertor</code> using the <code>Convertor(char const *)</code> constructor as
middleman:
        <pre>

    Convertor returnConvertorObject(char const *str)
    {
        return (str);
    }
        
</pre>

    This conversion will generally occur wherever possible, and appears to be
something like a `reversed' conversion operator: in applicable situation the
constructor expecting one argument will be used if the argument is specified,
and the class object is required.
<p><br>If such implicit use of a constructor is not appropriate, it can be
prevented by using the <code>explicit</code> modifier with the
constructor. Constructors for which the <code>explicit</code> modiefier are used can
only be used for the explcit definition of objects, and cannot be used 
as implicit type convertors anymore. For example, to prevent the implicit 
conversion from <code>char const *</code> to <code>Convertor</code> the class interface of the
class <code>Convertor</code> must contain the constructor
        <pre>

    explicit Convertor(char const *str);
        
</pre>

<p><br>
<p><br><a name="OVERLOADINCR"></a><a name="l96"></a>
<h2>6.7: Overloading ++ and --</h2>
<a name="overload/increment.yo"></a>
    Overloading the increment (and decrement) operator creates a slight problem:
there are two version of each operator, as they may be used as <em>postfix</em>
operator (e.g., <code>x++</code>) or as <em>prefix</em> operator (e.g., <code>++x</code>).
<p><br>Suppose we define a class <code>iterator</code> whose members can be used to visit the
elements of an array. The <code>iterator</code> object will return a pointer to an
element of the array, and the increment operators will change the pointer to
the next element. A partially defined <code>bvector</code> class is:
        <pre>
    class bvector
    {
        public:
            bvector(int *vector, unsigned size)
            :
                vector(vector),
                current(vector),
                finish(vector + size)
            {}
            int *begin()
            {
                return(current = vector);
            }
            operator int *() const
            {
                return (current);
            }
            // increment and decrement operators: see the text
        private:
            int 
                *vector,
                *current,
                *finish;
    };

    
</pre>

    In order to privide this class with an overloaded increment operator, the
following overloaded <code>operator++()</code> can be designed:
        <pre>

    int *bvector::operator++()
    {
        return (++current);
    }
        
</pre>

    As <code>current</code> is incremented before it is returned, the above overloaded
<code>operator++()</code> clearly behaves like the prefix operator. However, it is not
possible to use the same function to implement the postfix operator, as
overloaded functions must differ in their parameterlists. To solve this
problem, the convention is adopted to provide the <em>postfix</em> operator with a
(abstract) <code>int</code> parameter. So, the postfix increment operator can be
designed as follows:
        <pre>

    int *bvector::operator++(int)
    {
        return (current++);
    }
        
</pre>

    In situations where the function <code>operator++()</code> is called explicitly, a
dummy <code>int</code> argument may be passed to the function to indicate that the
postfix version is required. If no argument is provided, the prefix version of
the operator is used. E.g.,
        <pre>

    bvector
        *bvp = new bvector(intArray, 10);

    bvp-&gt;operator++(1); // postfix operator++()
    bvp-&gt;operator++()   // prefix operator++()
        
</pre>

<p><br>
<p><br><a name="FUNOBJ"></a><a name="l97"></a>
<h2>6.8: Function Objects</h2>
<a name="overload/functionobject.yo"></a>
    <em>Function Objects</em> are created by overloading the <em>function call</em> operator
<code>operator()</code>. By defining the function call operator an object may be called
as a function.
<p><br>Function objects play an important role in the <a href="cplusplus10.html#STL"><em>generic
algorithms</em></a> and they can be used profitably as alternatives to using
pointers to functions. The fact that they are important in the context of the
generic algorithms constitutes some sort of a didactical dilemma: at this
point it would have been nice if the generic algorithms would have been
covered, but for the discussion of the generic algorithms knowledge of
function objects is an advantage. This bootstrap problem is solved in a 
well known way: by ignoring the dependency.
<p><br>Function objects are <code>class type</code> objects for which the <code>operator()</code> has
been defined. Usually they are used in combination with the generic
algorithms, but they are also used in situations where otherwise pointers to
functions would have been used. Another reason for using function objects is
to support <code>inline</code> functions, something that is not possible via the
pointers to functions construction.
<p><br>Assume we have a class <code>Person</code> and an array of <code>Person</code> objects. The
array is not sorted. A well known procedure for finding a particular
<code>Person</code> object in the array is to use the function <code>lsearch()</code>, which
performs a <em>lineair</em> search in an array. A program fragment in which this
function is used is, e.g.,
    <pre>

        Person
            *pArray;
        unsigned
            n;

        n = fillPerson(&amp;pArray);

        Person
            target(...);

        cout &lt;&lt;
            "The target person is " &lt;&lt;
            (
                lsearch(&amp;target, pArray, &amp;n, sizeof(Person), compareFunction) ?
                    "found"
                :
                    "not found"
            ) &lt;&lt;
            endl;
    
</pre>

    The function <code>fillPerson()</code> is called to fill the array, the target
person is defined, and then <code>lsearch()</code> is used to locate the target person.
The comparison function must be available, as its address is passed over to
the function. It could be something like:
    <pre>

        int compareFunction(Person const *p1, Person const *p2)
        {
            return (*p1 != *p2);
        }
    
</pre>

    This, of course, assumes that the <code>operator!=()</code> has been overloaded in
the class <code>Person</code>, as it is quite unlikely that a bytewise comparison will
be appropriate here. But overloading <code>operator!=()</code> is no big deal, so let's
assume that operator is available as well. In this situation an <em>inline</em>
compare function cannot be used: as the address of the <code>comppare()</code> function
must be known to the <code>lsearch()</code> function. So, on the average <code>n / 2</code>
times <em>at least</em> the following actions take place:
    <ul>
        <li > The two arguments of the comparefunction are pushed on the stack,
        <li > The final parameter of <code>lsearch()</code> is evaluated, producing the 
address of <code>compareFunction()</code>,
        <li > The comparefunction is called,
        <li > The address of the right-hand argument of the
<code>Person::operator!=()</code>) argument is pushed on the stack,
        <li > The <code>operator!=()</code> function is evaluated,
        <li > The argument of <code>Person::operator!=()</code>) argument is popped off
the stack,
        <li > The two arguments of the comparefunction are popped off the stack.
    </ul>
<p><br>When using function objects a different picture emerges. Assume we have
constructed a function <code>PersonSearch()</code>, having the following prototype
(realize that this is not the real thing. Normally a generic algorithm will be
used instead of a home-made function. But for now our <code>PersonSearch()</code>
function is used for the sake of argument):
    <pre>

        Person const *PersonSearch(Person *base, size_t nmemb, 
                                    Person const &amp;target);
    
</pre>

    The next program fragment shows the use of this function:
    <pre>

        Person
            *pArray;
        unsigned
            n;

        n = fillPerson(&amp;pArray);

        cout &lt;&lt;
            "The target person is " &lt;&lt;
            (
                PersonSearch(pArray, n, Person(...)) ?
                    "found"
                :
                    "not found"
            ) &lt;&lt;
            endl;
    
</pre>

    Here we see that the target person is passed over to the function using an
anonymous <code>Person</code> object. A named object could have been used as well,
though. What happens inside <code>PersonSearch()</code> is shown next:
    <pre>

        Person const *PersonSearch(Person *base, size_t nmemb, 
                                    Person const &amp;target)
        {
            for (int idx = 0; idx &lt; nmemb; ++idx)
                if (target(base[idx]))
                    return (base + idx);
            return (0);
        }
    
</pre>

    The expression <code>target(base[idx])</code> shows our <code>target</code> object being
used as a function object. Its implementation can be something like:
    <pre>

        int Person::operator()(Person const &amp;other) const
        {
            return (*this != other);
        }
    
</pre>

    Note the somewhat peculiar syntax: <code>operator()(...)</code>. The first set of 
parentheses define the particular operator that is overloaded: the function
call operator. The second set of parentheses define the parameters that are
required for this function. The <code>operator()</code> appears in the class header
file as:
    <pre>

        int operator()(Person const &amp;other) const;
    
</pre>

    Now, <code>Person::operator()</code> is a simple function. It contains but one
statement, and we could consider making it inline. Assuming we do so, here is
what happens when the <code>operator()</code> is called:
    <ul>
        <li > The address of the right-hand argument of the
<code>Person::operator!=()</code>) argument is pushed on the stack,
        <li > The <code>operator!=()</code> function is evaluated,
        <li > The argument of <code>Person::operator!=()</code>) argument is popped off
the stack,
    </ul>
    Note that due to the fact that <code>operator()</code> is an inline function, it is
not actually called. Instead <code>operator!=()</code> is called immediately. 
Also note that the required stack operations are fairly modest.
<p><br>The <code>operator()</code> could have been avoided altogether in the above
example. However, in the coming sections several predefined function objects
are introduced calling specific operators of underlying datatypes. Usually
these function object will receive one or two arguments (for, respectively,
unary and binary operators). 
<p><br>Function objects play important roles in combination with 
generic algorithms. For example, there exists a generic algorithm <code>sort</code>
that takes two iterators defining the range of objects that should be sorted,
and a function object calling the appropriate comparison operator
for two objects. Let's take a quick look at this situation. Assume strings are
stored in a vector, and we want to sort the vector in descending order. In
that case, sorting the vector <code>stringVec</code> is as simple as:
    <pre>

        sort(stringVec.begin(), stringVec.end(), greater&lt;string&gt;());
    
</pre>

The last argument is in fact a <em>constructor</em> of the <code>greater</code> (template)
class applied on <code>strings</code>. This object is called (as function object) 
by the <code>sort()</code> generic algorithm. The function object itself is <em>not</em>
visible at this point: don't confuse the parentheses in <code>greater&lt;string&gt;()</code>
with the calling of the function object. When the function object is actually
called, it receives two arguments: two strings to compare for
`greaterness'. Internally, the <code>operator&gt;()</code> of the underlying datatype
(i.e., <code>string</code>) is called to compare the two objects. Since the
<code>greater::operator()</code> is defined <em>inline</em>, it is not actually present in
the code. Rather, the <code>string::operator&gt;()</code> is called by <code>sort()</code>. 
<p><br>Now that we know that a constructor is passed as argument to (many) generic
algorithms, we can design our own function objects. Assume we want to sort our
vector case-insensitively. How do we proceed? First we note that the default
<code>string::operator&lt;()</code> (for an incremental sort) is not appropriate, as it
does case sensitive comparisons. So, we provide our own <code>case_greater</code>
class, in which the two strings are compared case-insensitively. Using the
standard <strong>C</strong> function <code>strcasecmp()</code>, the following program performs the
trick. It sorts in increasing order its command-line arguments: 
        <pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;algorithm&gt;
#include &lt;string.h&gt;

class case_less
{
    public:
        bool operator()(string const &amp;left, string const &amp;right) const
        {
            return (strcasecmp(left.c_str(), right.c_str()) &lt; 0);
        }
};

int main(int argc, char **argv)
{
    sort(argv, argv + argc, case_less());
    for (int idx = 0; idx &lt; argc; ++idx)
        cout &lt;&lt; argv[idx] &lt;&lt; " ";
    cout &lt;&lt; endl;

    return (0);
}

</pre>

    The default constructor of the <code>class case_less</code> is used with the final
argument of <code>sort()</code>. The only memberfunction that must be defined with the
class <code>case_less</code> is the function object operator <code>operator()</code>. Since we
know it's called with <code>string</code> arguments, we provide it with two <code>string</code>
arguments, which are used in the <code>strcasecmp()</code> function. Furthermore, the
<code>operator()</code> function is made inline, so that it does not produce overhead
in the <code>sort()</code> function. The <code>sort()</code> function calls the function object
with various combinations of <code>strings</code>, i.e., it <em>thinks</em> it does
so. However, in fact it calls <code>strcasecmp()</code>, due to the inline-nature of
<code>case_less::operator()</code>. 
<p><br>The comparison function object is often a <em>predefined
function object</em>, since these are available for most of the common operations.
<p><br>A function object may be defined inline. This is not possible for
functions that are called indirectly (i.e., via pointers to functions). So,
even if the function objects needs to do very little work it has to be defined
as an ordinary function if it is going to be called via pointers. The overhead
of performing the indirect call may outweight the advantage of the flexibility
of calling functions indirectly. In these cases function objects that are
defined as inline functions can result in an increase of efficiency of the
program. Finally, function object may access the data of the objects for which
they are called directly, as they have access to the private data of their
object. In situations where a function must be able to serve many different
datatypes (like the <code>qsort()</code> function) it is always somewhat cumbersome to
reach the data of the involved objects via a pointer to a function of global
scope.
<p><br>In the following sections the available predefined function objects are
presented, together with some examples showing their use. At the end of this
section about function objects <em>function adaptors</em> are presented.
<p><br>
<p><br>
<p><br><a name="l98"></a>
<h3>6.8.1: Categories of Function objects</h3>
    <a name="overload/categories.yo"></a>
    Function objects may be defined when necessary. However, it is also (and
often) possible to use predefined function objects. In order to use the
predefined function objects the header file <code>functional</code> must be included:
    <pre>

        #include &lt;functional&gt;
    
</pre>

The predefined function objects are used predominantly with the generic
algorithms. Predefined function objects exists for arithmetic, relational, and
logical functions. They are discussed in the coming sections.
<p><br>
<p><br>
<a name="l99"></a>

             
<strong>6.8.1.1: Arithmetic Function Objects</strong><p>
        <a name="overload/arithmetic.yo"></a>
    The arithmetic function objects support the standard arithmetic operations:
addition, subtraction, multiplication, division, modulus and negation. By
using the predefined function objects, the corresponding operator of the
associated data type is invoked. For example, for the addition the function
object <code>plus&lt;Type&gt;</code> is available. If we set <code>type</code> to <code>unsigned</code> then
the <code>+</code> operator for unsigneds is used, if we set <code>type</code> to <code>string</code>,
then the <code>+</code> operator for strings is used. For example:
    <pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;functional&gt;

int main(int argc, char **argv)
{
    plus&lt;unsigned&gt;
        uAdd;       // function object to add unsigneds

    cout &lt;&lt; "3 + 5 = " &lt;&lt; uAdd(3, 5) &lt;&lt; endl;

    plus&lt;string&gt;
        sAdd;       // function object to add strings

    cout &lt;&lt; "argv[0] + argv[1] = " &lt;&lt; sAdd(argv[0], argv[1]) &lt;&lt; endl;
}

</pre>
 
    Why is this useful? Note that the function object can be used for all
kinds of data types, not only on the predefined datatypes, but on any (class)
type in which the particular operator has been overloaded. Assume that we want
to perform an operation on a common variable on the one hand and on each
element of an array in turn. E.g., we want to compute the sum of the elements
of an array, or we want to concatenate all the strings in a text-array. In
situations like these the function objects come in handy. As noted before, the
function objects are most heavily used in the context of the generic
algorithms, so let's take a quick look at one of them.
<p><br>On function of the generic algorithms is called <code>accumulate</code>. It visits all
elements implied by an iterator-range, and performs a requested binary
operation on a common element and each of the elements in the range, returning
the accumulated result after visiting all elements.
For example, the following program accumulates all its command line arguments,
and prints the final string:
        <pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;numeric&gt;

int main(int argc, char **argv)
{
    string
        result =
            accumulate(argv, argv + argc, string(""), plus&lt;string&gt;());

    cout &lt;&lt; "All concatenated arguments: " &lt;&lt; result &lt;&lt; endl;
}

</pre>

    The first two arguments define the (iterator) range of elements to visit,
the third argument is <code>string("")</code>. This anonymous string object provides an
initial value. It could as well have been initialized to
        <center><code>string("All concatenated elements: ")</code> </center>
    in which case the <code>cout</code> statement could have been a simple
        <center><code>cout &lt;&lt; result &lt;&lt; endl</code> </center>
    Then, the operator to apply is <code>plus&lt;string&gt;()</code>. Here it is important to
note the function call notation: it is <em>not</em> <code>plus&lt;string&gt;</code>, but rather
<code>plus&lt;string&gt;()</code>. The final concatenated string is returned.
<p><br>Now we define our own class data type <code>Time</code>, in which, e.g., the
<code>operator+()</code> has been overloaded. Again, we can apply the predefined
function object <code>plus</code>, now tailored to our newly defined datatype, to add
times:
    <pre>
#include &lt;iostream&gt;
#include &lt;strstream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;functional&gt;
#include &lt;numeric&gt;

class Time
{
    public:
        Time(unsigned hours, unsigned minutes, unsigned seconds)
        {
            days = 0;
            this-&gt;hours   = hours;
            this-&gt;minutes = minutes;
            this-&gt;seconds = seconds;
        }
        Time(Time const &amp;other)
        {
            this-&gt;days    = other.days;
            this-&gt;hours   = other.hours;
            this-&gt;minutes = other.minutes;
            this-&gt;seconds = other.seconds;
        }
        Time const operator+(Time const &amp;rValue) const
        {
            Time
                added(*this);
            added.seconds   += rValue.seconds;
            added.minutes   += rValue.minutes   + added.seconds / 60;
            added.hours     += rValue.hours     + added.minutes / 60;
            added.days      += rValue.days      + added.hours   / 24;
            added.seconds   %= 60;
            added.minutes   %= 60;
            added.hours     %= 24;
            return (added);
        } 
        operator char const *() const
        {
            static ostrstream
                timeString;

            timeString.seekp(ios::beg);
            timeString &lt;&lt; days &lt;&lt; " days, " &lt;&lt; hours &lt;&lt; ":" &lt;&lt; 
                        minutes &lt;&lt; ":" &lt;&lt; seconds &lt;&lt; ends;
            return (timeString.str());
        }
    private:
        unsigned
            days,
            hours,
            minutes,
            seconds;
};

int main(int argc, char **argv)
{
    vector&lt;Time&gt;
        tvector;

    tvector.push_back(Time( 1, 10, 20));
    tvector.push_back(Time(10, 30, 40));
    tvector.push_back(Time(20, 50,  0));
    tvector.push_back(Time(30, 20, 30));

    cout &lt;&lt; 
        accumulate
        (
            tvector.begin(), tvector.end(),
            Time(0, 0, 0), plus&lt;Time&gt;()
        ) &lt;&lt; endl;

}







</pre>

    Note that all memberfunctions of <code>Time</code> in the above source are
inline functions. This approach was followed in order to keep the example
relatively small, and to show explicitly that the <code>operator+()</code> function may
be an inline function. On the other hand, in real life the <code>operator+()</code>
function of <code>Time</code> should probably not be made inline, due to its
size. Considering the previous discussion of the <code>plus</code> function object, the
example is pretty straightforward. The class <code>Time</code> uses two constructors,
the second one being the copy-constructor, it uses a conversion operator
(operator char const *()) to produce a textual representation of the stored
time (deploying an <code>ostrstream</code> object, see chapter <a href="cplusplus11.html#IOStreams">11</a>), and it
defines its own <code>operator+()</code>, adding two time objects.
<p><br>The organization of the <code>operator+()</code> deserves some attention. In
expressions like <code>x + y</code> neither <code>x</code> nor <code>y</code> are modified. The result of
the addition is returned as a temporary value, which is then used in the rest
of the expression. Consequently, in the <code>operator+()</code> function the <code>this</code>
object and the <code>rValue</code> object must not be modified. Hence the <code>const</code>
modifier for the function, forcing <code>this</code> to be constant, and the <code>const</code>
modifier for <code>rValue</code>, forcing <code>rValue</code> to be constant. The sum of both
times is stored in a separate <code>Time</code> object, a copy of which is then
returned by the function. 
<p><br>In the <code>main()</code> function four times are stored in a <code>vector&lt;Time&gt;</code>
object. Then, the <code>accumulate()</code> generic algorithm is called to compute the
accumulated time. It returns a <code>Time</code> object, which cannot be inserted in
the <code>cout ostream</code> object. Fortunately, the conversion operator is
available, and this conversion operator is called implicitly to produce the
required <code>char const *</code> string from the <code>Time</code> object returned by the
<code>accumulate()</code> generic algorithm. 
<p><br>While the first example did show the use of a <em>named</em> function object,
the last two examples showed <em>unnamed</em> or <em>anonymous</em> objects which were
passed to the (<code>accumulate</code>) function.
<p><br>The following arithmetic objects are available as predefined objects:
    <ul>
        <li ><code>plus</code>, as shown this object calls the <code>operator+()</code>
        <li ><code>minus</code>, calling <code>operator-()</code> as a binary operator,
        <li ><code>multiplies</code>, calling <code>operator*()</code> as a binary operator,
        <li ><code>divides</code>, calling <code>operator/()</code>,
        <li ><code>modulus</code>, calling <code>operator%()</code>,
        <li ><code>negate</code>, calling <code>operator-()</code> as a unary operator.
    </ul>
    An example using the unary <code>operator-()</code> consider the following, in
which the <code>transform()</code> generic algorithm is used to toggle the signs of all
elements in an array. The <code>transform()</code> generic algorithm expects two
iterators, defining the range of objects to be transformed, an iterator
defining the begin of the destination range (which may be the same iterator as
the first argument) and a function object defining a unary operation for the
indicated data type. 
        <pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;algorithm&gt;

int main(int argc, char **argv)
{
    int
        iArr[] = { 1, -2, 3, -4, 5, -6 };

    transform(iArr, iArr + 6, iArr, negate&lt;int&gt;());

    for (int idx = 0; idx &lt; 6; ++idx)
        cout &lt;&lt; iArr[idx] &lt;&lt; ", ";

    cout &lt;&lt; endl;
}

</pre>


<p><br>
<a name="l100"></a>

             
<strong>6.8.1.2: Relational Function Objects</strong><p>
        <a name="overload/relational.yo"></a>
    The relational operators may be called from the relational function
objects. All the standard relational operators are supported: <code>==, !=, &gt;,
&gt;=, &lt;</code> and <code>&lt;=</code>. The following objects are available:
    <ul>
        <li ><code>equal_to&lt;Type&gt;</code>, calling <code>operator==()</code>,
        <li ><code>not_equal_to&lt;Type&gt;</code>, calling <code>operator!=()</code>,
        <li ><code>greater&lt;Type&gt;</code>, calling <code>operator&gt;()</code>,
        <li ><code>greater_equal&lt;Type&gt;</code>, calling <code>operator&gt;=()</code>,
        <li ><code>less&lt;Type&gt;</code>, calling <code>operator&lt;()</code>,
        <li ><code>less_equal&lt;Type&gt;</code>, calling <code>operator&lt;=()</code>.
    </ul>
        Like the arithmetic function objects, these function objects can be
used as <em>named</em> and <code>unnamed</code> too. An example using the relational
function objects using the generic algorithm <code>sort()</code> is:
        <pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;algorithm&gt;

int main(int argc, char **argv)
{
    sort(argv, argv + argc, greater_equal&lt;string&gt;());
    for (int idx = 0; idx &lt; argc; ++idx)
        cout &lt;&lt; argv[idx] &lt;&lt; " ";
    cout &lt;&lt; endl;

    sort(argv, argv + argc, less&lt;string&gt;());
    for (int idx = 0; idx &lt; argc; ++idx)
        cout &lt;&lt; argv[idx] &lt;&lt; " ";
    cout &lt;&lt; endl;

    return (0);
}

</pre>

    The <code>sort()</code> generic algorithm expects an iterator range and a
comparator object for the underlying data type. The example shows the
alphabetic sorting of strings and the reversed sorting of strings. By passing
<code>greater_equal&lt;string&gt;()</code> the strings are sorted in <em>decreasing</em> order
(the first word will be the 'greatest'), by passing <code>less&lt;string&gt;()</code> the
strings are sorted in <em>increasing</em> order (the first word will be the
'smallest').
<p><br>
<p><br>
<a name="l101"></a>

             
<strong>6.8.1.3: Logical Function Objects</strong><p>
        <a name="overload/logical.yo"></a>
    The logical operators may be called from the logical function
objects. The standard logical operators are supported: <code>&amp;&amp;, ||</code> and 
<code>!</code>. The following objects are available:
    <ul>
        <li ><code>logical_and&lt;Type&gt;</code>, calling <code>operator&amp;&amp;()</code>,
        <li ><code>logical_or&lt;Type&gt;</code>, calling <code>operator||()</code>,
        <li ><code>logical_not&lt;Type&gt;</code>, calling <code>operator!()</code> (unary operator).
    </ul>
    An example using the <code>operator!()</code> is the following trivial example, 
in which the <code>transform()</code> generic algorithm is used to transform the
logical values stored in an array:
        <pre>
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;functional&gt;
#include &lt;algorithm&gt;

int main(int argc, char **argv)
{
    bool
        bArr[] = {true, true, true, false, false, false};
    unsigned const
        bArrSize = sizeof(bArr) / sizeof(bool);

    for (int idx = 0; idx &lt; bArrSize; ++idx)
        cout &lt;&lt; bArr[idx] &lt;&lt; " ";
    cout &lt;&lt; endl;

    transform(bArr, bArr + bArrSize, bArr, logical_not&lt;bool&gt;());

    for (int idx = 0; idx &lt; bArrSize; ++idx)
        cout &lt;&lt; bArr[idx] &lt;&lt; " ";
    cout &lt;&lt; endl;

    return (0);
}

</pre>


<p><br><a name="l102"></a>
<h3>6.8.2: Function Adaptors</h3>
    <a name="overload/adaptors.yo"></a>
    Function adaptors modify the working of existing function objects. There are
two kinds of function adaptors:
    <ul>
        <li > The <em>binders</em> are function adaptors converting binary function
objects into unary function objects. They do so by <em>binding</em> one object to a
fixed function object. For example, with the <code>minus&lt;int&gt;</code> function object,
which is a binary function object, the first argument may be fixed to 100,
meaning that the resulting value will always be <code>100</code> minus the value of the
second argument. Either the first or the second argument may be bound to a
specific value. To bind the first argument to a specific value, the function
object <code>bind1st()</code> is used. To bind the second argument of a binary function
to a specific value <code>bind2nd()</code> is used. As an example, assume we want to
count all the elements in a vector of <code>Person</code> objects that exceeding
(according to some criterion) some reference <code>Person</code> object. For this
situation we pass the following binder and relational function object to the
<code>count_if()</code> generic algorithm:
    <pre>

        bind2nd(greater&lt;Person&gt;(), referencePerson)
    
</pre>

    The <code>count_if()</code> generic algorithm visits all the elements in an
iterator-range, returning the number of times the predicate specified in its
final argument returns <code>true</code>. Each of the elements of the iterator range is
given to the predicate, which is therefore a unary function. By using the
binder the binary function object <code>greater()</code> is adapted to a unary function
object, comparing each of the elements in the range to the reference person.
Here is, to be complete, the call of the <code>count_if()</code> function:
    <pre>

        count_if(pVector.begin(), pVector.end(), 
            bind2nd(greater&lt;Person&gt;(), referencePerson))
    
</pre>

        <li > The <em>negators</em> are function adaptors converting the truth value
of a predicate function. As are unary and binary predicate functions, there
are two negator function adaptors: <code>not1()</code> is the negator to be used with
unary function adaptors, <code>not2()</code> is the negator to be used with binary
function adaptors. 
    </ul>
<p><br>If we want to count the number of persons in a <code>vector&lt;Person&gt;</code> vector
<em>not</em> exceeding a certain reference person, we may, among other approaches,
use either of the following alternatives:
    <ul>
        <li > Use a binary predicate that directly offers the required
comparison: 
    <pre>

        count_if(pVector.begin(), pVector.end(), 
            bind2nd(less_equal&lt;Person&gt;(), referencePerson))
    
</pre>

        <li > Use <code>not2</code> in combination with the <code>greater()</code> predicate:
    <pre>

        count_if(pVector.begin(), pVector.end(), 
            bind2nd(not2(greater&lt;Person&gt;()), referencePerson))
    
</pre>

        <li > Use <code>not1</code> in combination with the <code>bind2nd()</code> predicate:
    <pre>

        count_if(pVector.begin(), pVector.end(), 
            not1(bind2nd((greater&lt;Person&gt;()), referencePerson)))
    
</pre>

    The following small example illustrates the use of the negator function
adaptors, completing the section on function objects:
    <pre>
#include &lt;iostream&gt;
#include &lt;functional&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;

int main(int argc, char **argv)
{
    int
       iArr[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

    cout &lt;&lt; count_if(iArr, iArr + 10, bind2nd(less_equal&lt;int&gt;(), 6)) &lt;&lt; 
        endl;
    cout &lt;&lt; count_if(iArr, iArr + 10, bind2nd(not2(greater&lt;int&gt;()), 6)) &lt;&lt; 
        endl;
    cout &lt;&lt; count_if(iArr, iArr + 10, not1(bind2nd(greater&lt;int&gt;(), 6))) &lt;&lt; 
        endl;

    return (0);
}

</pre>

    </ul>
<p><br>
<p><br><a name="OverloadableOperators"></a><a name="l103"></a>
<h2>6.9: Overloadable Operators</h2>
<a name="overload/overloadable"></a>
    The following operators can be overloaded:
<pre>

    +       -       *       /       %       ^       &amp;       |
    ~       !       ,       =       &lt;       &gt;       &lt;=      &gt;=
    ++      --      &lt;&lt;      &gt;&gt;      ==      !=      &amp;&amp;      ||
    +=      -=      *=      /=      %=      ^=      &amp;=      |=
    &lt;&lt;=     &gt;&gt;=     []      ()      -&gt;      -&gt;*     new     delete

</pre>

<p><br>However, some of these operators may only be overloaded as member functions
<em>within</em> a class. This holds true for the <code>'='</code>, the <code>'[]'</code>, the 
<code>'()'</code> and the <code>'-&gt;'</code> operators. Consequently, it isn't possible
to redefine, e.g., the assignment operator globally in such a way that
it accepts a <code>char const *</code> as an <code>lvalue</code> and a <code>String &amp;</code> as an
<em>rvalue</em>. Fortunately, that isn't necessary, as we have seen in section 
<a href="cplusplus06.html#ConversionOperators">6.5</a>. 


<p><br>


<hr>
<ul>
    <li> <a href="cplusplus07.html">Next chapter</a>
    <li> <a href="cplusplus05.html">Previous chapter</a>
    <li> <a href="cplusplus.html">Table of contents</a>
</ul>
<hr>
</body>
</html>
