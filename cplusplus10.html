<html>
<head>
<title>C++ Annotations
        Version 4.4.0k </title>
</head>
<body fgcolor="black" bgcolor="white"  >
<hr>
<ul>
    <li> <a href="cplusplus11.html">Next chapter</a>
    <li> <a href="cplusplus09.html">Previous chapter</a>
    <li> <a href="cplusplus.html">Table of contents</a>
</ul>
<hr>

<a name="STL"></a><a name="l130"></a>
<h1>Chapter 10: The Standard Template Library, generic algorithms</h1>
<a name="stl"></a>
    
<blockquote>
    <em>
        We're always interested in getting feedback. E-mail us if you like
        this guide, if you think that important material is omitted, if you
        encounter errors in the code examples or in the documentation, if you
        find any typos, or generally just if you feel like e-mailing. Mail to
        <a href="http://www.icce.rug.nl/frank/">Frank Brokken</a>
        or use an
        <a href="http://www.icce.rug.nl/frank/efrank.html">e-mail form</a>.
        Please state the concerned document version, found in
        the title. 
    </em>
</blockquote>
<p><br>
<p><br><a name="stl/intro.yo"></a>
    The <code>Standard Template Library</code> (STL) consists of containers, generic
algorithms, iterators, function objects, allocators and adaptors. The STL is a
general purpose library consisting of algorithms and data structures. The data
structures that are used in the algorithms are <em>abstract</em> in the sense that
the algorithms can be used on (practically) every data type. 
<p><br>The algorithms can work on these abstract data types due to the fact that they
are <em>template</em> based algorithms. In this chapter the <em>construction</em> of
these templates in not further discussed (see chapter <a href="cplusplus16.html#Templates">16</a> for
that). Rather, the <em>use</em> of these template algorithms is the focus of this
chapter. 
<p><br>Several parts of the standard template library have already been discussed in
the <strong>C++</strong> Annotations. In chapter <a href="cplusplus07.html#Containers">7</a> the abstract containers
were discussed, and in section <a href="cplusplus06.html#FUNOBJ">6.8</a> function objects and adaptors 
were covered. Also, <em>iterators</em> were mentioned at several places in this
document.
<p><br>The remaining components of the STL will be covered in this
chapter. Iterators, and the generic algorithms will be discussed in
the coming sections. <em>Allocators</em> take care of the memory allocation within
the STL. The default allocator class suffices for most applications. 
<p><br>Forgetting to delete allocated memory is a common source of errors or memory
leaks in a program. The <code>auto_ptr</code> template class may be used to prevent
these types of problems. The <code>auto_ptr</code> class is discussed in section
<a href="cplusplus10.html#AUTOPTR">10.2</a> of this chapter.
<p><br>
<p><br><a name="ITERATORS"></a><a name="l131"></a>
<h2>10.1: Iterators</h2>
<a name="stl/iterators"></a>
    Iterators are an abstraction of pointers. In general, the following holds true
of iterators: 
    <ul>
        <li > Given an iterator <code>iter</code>, <code>*iter</code> represents the object the
iterator points to (alternatively, <code>iter-&gt;</code> can be used to reach the object
the iterator points to).
        <li > <code>++iter</code> or <code>iter++</code> advances the iterator to the next
element. The notion of advancing an iterator to the next element is
consequently applied: several containers have a <em>reversed</em> iterator type, in
which the <code>iter++</code> operation actually reaches an previous element in a
sequence. 
        <li > For the containers that have their elements stored consecutively
in memory <em>pointer arithmetic</em> is available as well. This counts out the
<code>list</code>, but includes the <code>vector, queue, deque, set</code> and <code>map</code>. For
these containers <code>iter + 2</code> points to the second element beyond the one to
which <code>iter</code> points.
    </ul>
    The STL containers produce iterators (i.e., type <code>iterator</code>) using
member functions <code>begin()</code> and <code>end()</code> and, in the case of reversed
iterators (type <code>reverse_iterator</code>), <code>rbegin()</code> and <code>rend()</code>. Standard
practice requires the iterator range to be <em>left inclusive</em>: the notation
<code>[left, right)</code> indicates that <code>left</code> is an iterator pointing to the
first element that is to be considered, while <code>right</code> is an iterator
pointing just <em>beyond</em> the last element to be used. The iterator-range is
said to be <em>empty</em> when <code>left == right</code>.
<p><br>The following example shows a situation where all elements of a vector of
strings are written to <code>cout</code> using the iterator range 
<code>[begin(), end())</code>, and the iterator range <code>[rbegin(),
rend())</code>. Note that the <code>for-loops</code> for both ranges are identical:
<p><br><pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;

int main(int argc, char **argv)
{
    vector&lt;string&gt;
        args(argv, argv + argc);

    for 
    (
        vector&lt;string&gt;::iterator iter = args.begin();
            iter != args.end();
                ++iter
    )
        cout &lt;&lt; *iter &lt;&lt; " ";

    cout &lt;&lt; endl;

    for 
    (
        vector&lt;string&gt;::reverse_iterator iter = args.rbegin();
            iter != args.rend();
                ++iter
    )
        cout &lt;&lt; *iter &lt;&lt; " ";

    cout &lt;&lt; endl;
    
    return (0);
}

</pre>

<p><br>Furthermore, the STL defines <em>const_iterator</em> types to be able to visit
a range of the elements in a constant container. Whereas the elements of the
vector in the previous example could have been altered, the elements of the
vector in the next example are immutable, and <code>const_iterator</code>s are
required: 
<p><br><pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;

int main(int argc, char **argv)
{
    const vector&lt;string&gt;
        args(argv, argv + argc);

    for 
    (
        vector&lt;string&gt;::const_iterator iter = args.begin();
            iter != args.end();
                ++iter
    )
        cout &lt;&lt; *iter &lt;&lt; " ";

    cout &lt;&lt; endl;

    for 
    (
        vector&lt;string&gt;::const_reverse_iterator iter = args.rbegin();
            iter != args.rend();
                ++iter
    )
        cout &lt;&lt; *iter &lt;&lt; " ";

    cout &lt;&lt; endl;
    
    return (0);
}

</pre>

<p><br>The examples also illustrate the use of plain pointers for iterators. The
initialization <code>vector&lt;string&gt; sarg(argv, argv + argc)</code> provides the
<code>sarg</code> vector with a pair of pointer-based iterators: <code>argv</code> points to the
first element to initialize <code>sarg</code> with, <code>argv + argc</code> points just beyond
the last element to be used, <code>argv++</code> reaches the next string. This is a
general characteristic of pointers, which is why they too can be used in
situations where <code>iterators</code> are expected. 
<p><br>The STL defines five types of iterators. These types recur in the generic
algorithms, and in order to be able to create a particular type of iterator
yourself it is important to know their characteristic. In genral, it must be
possible to 
        <ul>
            <li > test iterators for equality (<code>==</code>)
            <li > test iterators for inequality (<code>!=</code>)
            <li > increment iterators using the prefix or postfix increment
operator (<code>++</code>)
            <li > access the element iterators refer to using the dereference
operator (<code>*</code>).
        </ul>
    <ul>
        <li><strong>InputIterators:</strong> InputIterators can read elements from a
container.  The dereference operator is guaranteed to work as an <code>rvalue</code> in
an expression, not as an <code>lvalue</code>. Instead of an InputIterator it is also
possible to (see below) use a Forward-, Bidirectional- or
RandomAccessIterator.
        <li><strong>OutputIterators:</strong> OutputIterators can be used to write to a
container. The dereference operator is guaranteed to work as an <code>lvalue</code> in
an expression, not as an <code>rvalue</code>. Instead of an OutputIterator it is also
possible to (see below) use a Forward-, Bidirectional- or
RandomAccessIterator.
        <li><strong>ForwardIterators:</strong> ForwardIterators combine InputIterators and
OutputIterators. They can be used to traverse the container in one direction,
for reading and/or writing. Instead of a ForwardIterator it is also possible
to (see below) use a Bidirectional- or RandomAccessIterator.
        <li><strong>BidirectionalIterators:</strong> BidirectionalIterators allow the
traversal of a container in both directions, for reading and writing. Instead
of a ForwardIterator it is also possible to (see below) use a
RandomAccessIterator. For example, to traverse a list or a deque a
BidirctionalIterator may be useful.
        <li><strong>RandomAccessIterators:</strong> RandomAccessIterators provide access to
any element of the container at any moment. An algorithm such as <code>sort()</code>
requires a RandomAccessIterator, and can therefore not be used with lists or
maps, which only provide BidirectionalIterators.
    </ul>
The example given with the RandomAccessIterator provides an approach towards
iterators: look for the iterator that's required by the (generic) algorithm,
and then see whether the datastructure supports the required iterator or
not. If not, the algorithm cannot be used with the particular datastructure. 
<p><br>
<p><br>
    <a name="INSERTER"></a><a name="l132"></a>
<h3>10.1.1: Insert iterators</h3>
    <a name="stl/insertiterators"></a>
    The generic algorithms often require a target container into which the results
of the algorithm are deposited. For example, the <a href="cplusplus10.html#COPY"><code>copy()</code></a>
algorithm has three parameters, the first two of them define the range of
elements which are visited, and the third parameter defines the first position
where the result of the copy operation is to be stored. With the <code>copy()</code>
algorithm the number of elements that are copied are normally available
beforehand, since the number is normally equal to the number of elements in
the range defined by the first two parameters, but this does not always hold
true. Sometimes the number of resulting elements is different from the number
of elements in the initial range. The generic algorithm
<a href="cplusplus10.html#UNIQUECOPY"><code>unique_copy()</code></a> is a case in point: the number of elements
which are copied to the destination container is normally not known
beforehand. 
<p><br>In situations like these, the <code>inserter()</code> adaptor functions may be used to
create elements in the destination container when they are needed.
<p><br>There are three <code>inserter()</code> adaptors:
<p><br><ul>
        <li ><code>back_inserter()</code> calls the container's <code>push_back()</code> insert
member to add new elements at the end of the container. E.g.,
    <pre>

        copy(source.rbegin(), source.rend(), back_inserter(destination));
    
</pre>

will copy all elements of <code>source</code> in reversed order to the back of
<code>destination</code>. 
        <li ><code>front_inserter()</code> calls the container's <code>push_front()</code> insert
member to add new elements at the beginning of the container. E.g.,
    <pre>

        copy(source.begin(), source.end(), front_inserter(destination));
    
</pre>

will copy all elements of <code>source</code> to the front of the destination container
(thereby also reversing the order of the elements).
        <li ><code>inserter()</code> calls the container's <code>insert()</code> member to add new
elements starting at a specified starting point within the container. E.g.,
    <pre>

        copy(source.begin(), source.end(), inserter(destination,
destination.begin()));
    
</pre>

will copy all elements of <code>source</code> to the destination container, starting at
the beginning of <code>destination</code>.
    </ul>

<p><br>
    <a name="ISTREAMITERATORS"></a><a name="l133"></a>
<h3>10.1.2: istream iterators</h3>
    <a name="stl/istreamiterators"></a>
    The <code>istream_iterator&lt;Type&gt;()</code> can be used to define an iterator (pair) for
an <code>istream</code> object or for a subtype of an <code>istream</code>. The general form of
the <code>istream_iterator&lt;Type&gt;()</code> iterator is:
    <center><code>istream_iterator&lt;Type&gt; identifier(istream &amp;inStream)</code> </center>
    Here, <code>Type</code> is the type of the data elements that are to be read from
the <code>istream</code> stream. <code>Type</code> may be any of the types for which the
<code>operator&gt;&gt;()</code> is defined with <code>istream</code> objects. 
<p><br>The default (empty) constructor defines the end of the iterator pair,
corresponding to <code>end-of-stream</code>. For example,
    <center><code>istream_iterator&lt;string&gt; endOfStream;</code> </center>
    Note that the actual <em>stream</em> object which is specified for the
begin-iterator is <em>not</em> mentioned here. 
<p><br>Using a <a href="cplusplus10.html#INSERTER"><code>back_inserter()</code></a> and a set of
<code>istream_iterator&lt;&gt;()</code>s all strings could be read from <code>cin</code> as follows:
    <pre>
#include &lt;algorithm&gt;
#include &lt;iterator&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

int main()
{
    vector&lt;string&gt;
        vs;

    copy(istream_iterator&lt;string&gt;(cin), istream_iterator&lt;string&gt;(),
         back_inserter(vs));

    for 
    (
        vector&lt;string&gt;::iterator from = vs.begin();
            from != vs.end();
                ++from
    )
        cout &lt;&lt; *from &lt;&lt; " ";
    cout &lt;&lt; endl;

    return (0);
}
</pre>

    In the above example, note the use of the anonymous versions of the
<code>istream_iterator</code>s. Especially note the use of the anonymous default
constructor. Instead of using <code>istream_iterator&lt;string&gt;()</code> the
(non-anonymous) construction
    <pre>

    istream_iterator&lt;string&gt;
            eos;

    copy(istream_iterator&lt;string&gt;(cin), eos, back_inserter(vs));
    
</pre>

    could have been used.
<p><br>The <code>istream_iterator</code> iterators is available when the <code>iterator</code>
header file is included. This is, e.g., the case when  <code>iostream</code> is
included. 
<p><br>
<p><br><a name="l134"></a>
<h3>10.1.3: ostream iterators</h3>
    <a name="stl/ostreamiterators"></a>
    The <code>ostream_iterator&lt;Type&gt;()</code> can be used to define a destination iterator
for an <code>ostream</code> object or for a subtype of an <code>ostream</code>. The general forms
of the <code>ostream_iterator&lt;Type&gt;()</code> iterator are:
    <center><code>ostream_iterator&lt;Type&gt; identifier(ostream &amp;inStream)</code> </center>
and
    <center><code>ostream_iterator&lt;Type&gt; identifier(ostream &amp;inStream), char const
            *delimiter</code> </center>  
    <code>Type</code> is the type of the data elements that are to be written to the
<code>ostream</code> stream. <code>Type</code> may be any of the types for which the
<code>operator&lt;&lt;()</code> is defined with <code>ostream</code> objects.  The latter form of the
<code>ostream_iterators</code> separates the individual <code>Type</code> data elements by
<code>delimiter</code> strings. The former form does not use any delimiters.
<p><br>The following example shows the use of a
<a href="cplusplus10.html#ISTREAMITERATORS"><code>istream_iterators</code></a> and an <code>ostream_iterator</code> to
copy information of a file to another file. A subtlety is the statement
<code>in.flags(in.flags() &amp; ~ios::skipws)</code>: it retrieves the actual flags of the
<code>ifstream in</code> variable, and immediately resets the <code>ios::skipws</code> flag. The
consequence of this is that the default behavior of the <code>operator&gt;&gt;()</code>, to
skip whitespace, is modified. White space characters are simply returned by
the operator, and the file is copied unrestrictedly. Here is the program:
    <pre>
#include &lt;algorithm&gt;
#include &lt;fstream&gt;
#include &lt;iomanip&gt;

int main(int argc, char **argv)
{
    ifstream
        in(argv[1]);
    ofstream
        out(argv[2]);

    in.flags(in.flags() &amp; ~ios::skipws);

    copy(istream_iterator&lt;char&gt;(in), istream_iterator&lt;char&gt;(),
         ostream_iterator&lt;char&gt;(out));

    return (0);
}
</pre>

<p><br>The <code>ostream_iterator</code> iterators are available when the <code>iterator</code>
header file is included. This is, e.g., the case when  <code>iostream</code> is
included. 
<p><br>
<p><br><a name="AUTOPTR"></a><a name="l135"></a>
<h2>10.2: The 'auto_ptr' class</h2>
<a name="stl/autoptr"></a>
    One of the problems using pointers is that strict bookkeeping is required
about the memory the pointers point to. When a pointer variable goes out of
scope, the memory pointed to by the  pointer is suddenly inaccessible, and
the program suffers from a memory leak. For example, in the following code, 
a memory leak is introduced in which 200 <code>int</code> values remain allocated:
<pre>

    #include &lt;iostream&gt;

    int main()
    {
        for (int idx = 0; idx &lt; 200; ++idx)
        {
            int
                c,
                *ip;

            cin &gt;&gt; c;               // read an int
            ip = new int(c);        // ip points to int initialized to 'c'
        }                           // no delete-operation
        next();                     // whatever comes next
        return (0);
    }

</pre>

<p><br>The standard way to prevent  memory leakage is strict bookkeeping: the
programmer has to make sure that the memory pointed to by a pointer is deleted
just before the pointer variable dies. In the above example the repair would
be: 
<p><br><pre>

    #include &lt;iostream&gt;

    int main()
    {
        for (int idx = 0; idx &lt; 200; ++idx)
        {
            int
                c,
                *ip;

            cin &gt;&gt; c;               // read an int
            ip = new int(c);        // ip points to int initialized to 'c'
            delete ip;              // and delete the allocated memory again
        }                           
        next();                     // whatever comes next
        return (0);
    }

</pre>

<p><br>When a pointer variable is used to point to <em>a single value or object</em>, the
bookkeeping becomes less of a burden when the pointer variable is defined as a
<code>auto_ptr</code> object. The template class <code>auto_ptr</code> is available when the
header file <code>memory</code> is included. 
<p><br>Normally, an <code>auto_ptr</code> object is initialized to point to a dynamically
created value or object. When the <code>auto_ptr</code> object goes out of scope, the
memory pointed to by the object is automatically deleted, taking over 
the programmer's responsibility to delete memory. 
<p><br>Alternative forms to create <code>auto_ptr</code> objects are available as well, as
discussed in the coming sections.
<p><br>Note that 
    <ul>
        <li > the <code>auto_ptr</code> object cannot be used to point to arrays of
objects. 
        <li > an <code>auto_ptr</code> object should only point to memory
that was made available dynamically, as only dynamically allocated memory can
be deleted. 
        <li > multiple <code>auto_ptr</code> objects should not be allowed to point to
the same block of dynamically allocated memory. Once one <code>auto_ptr</code> object
goes out of scope, it deletes the memory it points to, immediately rendering
the other objects wild. Ways to prevent this situation are discussed below.
    </ul>
The <code>class auto_ptr</code> has several memberfunctions which can be used to access
the pointer itself and to have the <code>auto_ptr</code> point to another block of
memory. These memberfunctions are discussed in the following sections as well.
<p><br><em>Note:</em>
<blockquote>
By the time these annotations were written the <code>memory</code> header file which
must be included to use the <code>auto_ptr</code> objects was still incomplete. A
modified <code>memory</code> header file which can be used to replace the current
incomplete file can be found at
 <a href="ftp://ftp.icce.rug.nl/pub/frank/egcs/memory">ftp://ftp.icce.rug.nl/pub/frank/egcs/memory</a>. This file can replace the
<code>memory</code> file in (on <strong>Linux</strong> systems) <code>/usr/include/g++</code>, and on
computers running <strong>MS-Windows</strong> in <code>Cygnus/B19/include/g++/memory</code>. 
 </blockquote>
<p><br>
<p><br><a name="l136"></a>
<h3>10.2.1: Defining auto_ptr variables</h3>
    <a name="stl/defining"></a>
    There are three ways to define <code>auto_ptr</code> objects. Each definition contains
the usual <code>&lt;type&gt;</code> specifier between pointed brackets. Concrete examples are
given in the coming sections, but an overview of the various possibilities is
presented here:
    <ul>
        <li > The basic form initializes an <code>auto_ptr</code> object to a block
of memory that's allocated by the <code>new</code> operator:
    <center><code>auto_ptr&lt;type&gt; identifier (new-expression);</code> </center>
This form is discussed in the next section <a href="cplusplus10.html#AUTONEW">10.2.2</a>.
        <li > Another form initializes an <code>auto_ptr</code> object through 
another <code>auto_ptr</code> object:
    <center><code>auto_ptr&lt;type&gt; identifier(another auto_ptr for type);</code> </center>
This form is discussed in the next section <a href="cplusplus10.html#AUTOOTHER">10.2.3</a>.
        <li > The third form simply creates an <code>auto_ptr</code> object that
does not point to a particular block of memory:
    <center><code>auto_ptr&lt;type&gt; identifier;</code> </center>
This form is discussed in the next section <a href="cplusplus10.html#AUTOPLAIN">10.2.4</a>.
    </ul>

<p><br>
    <a name="AUTONEW"></a><a name="l137"></a>
<h3>10.2.2: Pointing to a newly allocated object</h3>
    <a name="stl/autonew"></a>
    The basic form to initialize an <code>auto_ptr</code> object is to pass its constructor
a block of memory that's allocated by the <code>new</code> operator. The generic form
is: 
    <center><code>auto_ptr&lt;type&gt; identifier (new-expression);</code> </center>
<p><br>For example, to initialize an <code>auto_ptr</code> to a <code>string</code> variable the
construction 
    <center><code>auto_ptr&lt;string&gt; strPtr (new string("Hello world"));</code> </center>
can be used. To initialize an <code>auto_ptr</code> to a <code>double</code> variable the
construction 
    <center><code>auto_ptr&lt;double&gt; dPtr (new double(123.456));</code> </center>
can be used.
<p><br>Note the use of the operator <code>new</code> in the above expressions. The use of the
operator <code>new</code> ensures the dynamic nature of the memory pointed to by the
<code>auto_ptr</code> objects, and allows the deletion of the memory once the
<code>auto_ptr</code> objects go out of scope. Also note that the <code>type</code> does <em>not</em>
contain the pointer: the <code>type</code> used in the <code>auto_ptr</code> construction is the
same type as used in the <code>new</code> expression.
<p><br>In the example of the 200 <code>int</code> values given earlier, the memory leak can be
avoided by using <code>auto_ptr</code> objects as follows:
<pre>

    #include &lt;iostream&gt;
    #include &lt;memory&gt;

    int main()
    {
        for (int idx = 0; idx &lt; 200; ++idx)
        {
            int
                c;

            cin &gt;&gt; c;               // read an int
            auto_ptr&lt;int&gt; ip (new int(c));
        }                           // no delete-operation needed
        return (0);
    }

</pre>

    Following each cycle of the for loop, the memory allocated by the <code>new
int(c)</code> expression is deleted automatically.
<p><br>All member functions that are available for objects that are allocated by the
<code>new</code> expression (like the <code>string</code> object in the first example in this
section) can be reached via the <code>auto_ptr</code> as if it was a plain pointer to
the dynamically allocated object. E.g., to insert some text beyond the wordt
<code>hello</code> in the string pointed to by <code>strPtr</code>, an expression like
    <center><code>strPtr-&gt;insert(strPtr-&gt;find_first_of(" ") + 1, "C++ ");</code> </center>
 can be used.

<p><br>
    <a name="AUTOOTHER"></a><a name="l138"></a>
<h3>10.2.3: Pointing to another auto_ptr</h3>
    <a name="stl/autoother"></a>
    Another form to initialize an <code>auto_ptr</code> object is to initialize it from
another <code>auto_ptr</code> object for the same type.  The generic form is:
    <center><code>auto_ptr&lt;type&gt; identifier (other auto_ptr object);</code> </center>
<p><br>For example, to initialize an <code>auto_ptr</code> to a <code>string</code> variable, given the
<code>strPtr</code> variable defined in the previous section, the construction 
    <center><code>auto_ptr&lt;string&gt; newPtr(strPtr);</code> </center>
can be used.
<p><br>A comparable construction can be used with the assignment operator in
expressions. One <code>auto_ptr</code> object may be assigned to another <code>auto_ptr</code>
object of the same type. For example:
<pre>

    #include &lt;iostream&gt;
    #include &lt;memory&gt;
    #include &lt;string&gt;

    int main()
    {
        auto_ptr&lt;string&gt; 
            hello(new string("Hello world")),
            hello2(hello),
            hello3(new string("Another string"));

        hello3 = hello2;
        return (0);
    }        

</pre>

    Looking at the above example, we see that <code>hello</code> is initialized as
described in the previous section. A <code>new</code> expression is used to allocate a
<code>string</code> variable dynamically. Next, <code>hello2</code> is initialized to <code>hello</code>,
which is possible, as they are <code>auto_ptr</code> objects of the same
types. However, in order to prevent problems when either object goes out of
scope, special measures are required. 
<p><br>If the program would stop here, both <code>hello</code> and <code>hello2</code> go out of
scope. But only <code>hello2</code> would point to the dynamically allocated string
<code>hello world</code>: once a <code>auto_ptr</code> object is used to initialize another
<code>auto_ptr</code> object, the former (initializing) object does not refer anymore
to the allocated string. The string is now `owned' by the latter (initialized)
object. 
<p><br>A comparable action takes place in the assignment statement <code>hello3 =
hello2</code>. Here, prior to the actual assignment, the memory pointed to by
<code>hello3</code> is deleted automatically. Then <code>hello3</code> gains the ownership of
the string <code>Hello world</code>, and <code>hello2</code> cannot be used anymore to reach the
string <code>Hello world</code>.
<p><br>
<p><br>
    <a name="AUTOPLAIN"></a><a name="l139"></a>
<h3>10.2.4: Creating an plain auto_ptr</h3>
    <a name="stl/autoplain"></a>
    The third form to create an <code>auto_ptr</code> object simply creates an empty
<code>auto_ptr</code> object that does not point to a particular block of memory:
    <center><code>auto_ptr&lt;type&gt; identifier;</code> </center>
<p><br>In this case the underlying pointer is set to <code>0</code> (zero). Since the
<code>auto_ptr</code> object itself is not the pointer, its value cannot be compared to
<code>0</code> to see if it has not been initialized. E.g., code like
<pre>

    auto_ptr&lt;int&gt;
        ip;

    if (!ip)
        cout &lt;&lt; "0-pointer with an auto_ptr object ?" &lt;&lt; endl;

</pre>

    will not produce any output (actually, it won't compile either...). So,
how do we inspect the value of the pointer that's maintained by the
<code>auto_ptr</code> object? For this the member <code>get()</code> is available. This member
function, as well as the other member functions of the class <code>auto_ptr</code> are
described in the following sections.

<p><br><a name="l140"></a>
<h3>10.2.5: The get() memberfunction</h3>
    <a name="stl/get"></a>
    The memberfunction <code>get()</code> of an <code>auto_ptr</code> object returns the underlying
pointer. The value returned by <code>get()</code> is a pointer to the underlying
data-type. It may be inspected: if it's zero the <code>auto_ptr</code> object does not
point to any memory.
<p><br>The memberfunction <code>get()</code> cannot be used to let the <code>auto_ptr</code> object
point to (another) block of memory. Instead the memberfunction
<code>reset()</code>, discussed in the next section, should be used.

<p><br><a name="l141"></a>
<h3>10.2.6: The reset() memberfunction</h3>
    <a name="stl/reset"></a>
    The memberfunction <code>reset()</code> of an <code>auto_ptr</code> object can be used to
(re)assign a block of memory allocated by the operator <code>new</code> to an
<code>auto_ptr</code>.  The function <code>reset()</code> does not return a value.
<p><br>An example of its use is:
<pre>

    auto_ptr&lt;string&gt;
        str;

    str.reset(new string("Hello"));         // assignment of a value
    str.reset(new string("Hello world"));   // reassignment of a value
 
</pre>

 The object that is assigned to the pointer using <code>reset()</code> must have been
allocated using the <code>new</code> operator. The object the pointer points to just
before applying <code>reset()</code>) is deleted first. The value <code>0</code> can be passed
to <code>reset()</code> if the object pointed to by the pointer should be
deleted. Following <code>reset(0)</code> the pointer variable has been reinitialized.
<p><br>Note that it is usually more efficient to use a reassignment memberfunction of
the object pointed to by the pointer if the only purpose of the exercise is to
redefine the value of the object. For example, the <code>string</code> class supports a
function <code>assign()</code> which may be used for that purpose. So, a construction
like:
 <pre>

        auto_ptr&lt;string&gt;
            aps(new string("Hello"));

        aps.reset("Hello world");
 
</pre>

 can more efficiently be implemented as:
 <pre>

        auto_ptr&lt;string&gt;
            aps(new string("Hello"));

        aps-&gt;assign("Hello world");
 
</pre>

<p><br>
<p><br><a name="l142"></a>
<h3>10.2.7: The release() memberfunction</h3>
    <a name="stl/release"></a>
    As we saw in section <a href="cplusplus10.html#AUTOOTHER">10.2.3</a>, when an <code>auto_ptr</code> is assigned to
another <code>auto_ptr</code>, the pointer providing the value looses its value and is
reinitialized to 0. If that's not what we want, the memberfunction
<code>release()</code> may be used. 
<p><br>The <code>release()</code> memeberfunction returns the address of the underlying
pointer used by the <code>auto_ptr</code> object, and releases the ownership of the
object at the same time. The ownership can then be taken over by another
<code>auto_ptr</code> variable (or, indeed, by any other pointer).
<p><br>In the following example a pointer is initialized, and then another pointer is
created to point to the same string as the first <code>auto_ptr</code> points to. The
first <code>auto_ptr</code> still points to the string, but doesn't own the string
anymore. Therefore, when the first <code>auto_ptr</code> goes out of scope, it won't
delete the string pointed to by the second <code>auto_ptr</code>.
 <pre>
    #include &lt;memory&gt;
    #include &lt;string&gt;

    int main()
    {
        auto_ptr&lt;string&gt;
            first;

        {
            auto_ptr&lt;string&gt;
                second(new string("Hello world"));

            first.reset(second.release());

            cout &lt;&lt; "Second auto_ptr still points at: " &lt;&lt; *second &lt;&lt; endl
                &lt;&lt; "First auto_ptr also points to: " &lt;&lt; *first &lt;&lt; endl;
        }
        cout &lt;&lt; "Second object now out of scope. First auto_ptr\n"
            "still points at: " &lt;&lt; *first &lt;&lt; endl;
    }
</pre>


<p><br><a name="l143"></a>
<h2>10.3: The Generic Algorithms</h2>
<a name="stl/generic"></a>
    The following sections describe the generic algorithms in alphabetical
order. For each algorithm the following information is provided:  
    <ul>
        <li > The required header file(s)
        <li > The function prototype
        <li > A short description
        <li > A short example.
    </ul>
In the prototypes of the algorithms <code>Type</code> is used to specify a generic
(i.e., template) datatype. The particular kind of iterator that is required is
mentioned, and possibly other generic types, e.g., performing
<code>BinaryOperations</code>, like <code>plus&lt;Type&gt;()</code>. 
<p><br>Almost every generic algorithm has as its first two arguments an iterator
range <code>[first, last)</code>, defining the range of elements on which the
algorithm operates. 
<p><br>
<p><br><a name="l144"></a>
<h3>10.3.1: accumulate()</h3>
    <a name="stl/accumulate"></a>
        <ul>
        <li > Header file: 
        <pre>
#include&lt;numeric&gt;
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>Type accumulate(InputIterator first, InputIterator last, Type
init);</code>
            <li ><code>Type accumulate(InputIterator first, InputIterator last, Type
init, BinaryOperation op);</code>
        </ul>
        <li > Description:
        <ul>
            <li > The first prototype: the <code>operator+()</code> is applied to all
elements implied by the iterator range and to the initial value <code>init</code>, and
the resulting value is returned.
            <li > The second prototype: the <code>op()</code> is applied to all
elements implied by the iterator range and to the initial value <code>init</code>, and
the resulting value is returned.
        </ul>
        <li > Example:
        <pre>
#include&lt;numeric&gt;
#include&lt;vector&gt;
#include&lt;iostream&gt;

int main()
{
    int
        ia[] = {1, 2, 3, 4};
    vector&lt;int&gt;
        iv(ia, ia + 4);

    cout &lt;&lt; 
        "Sum of values: " &lt;&lt; accumulate(iv.begin(), iv.end(), int(0)) &lt;&lt;
        endl &lt;&lt;
        "Product of values: " &lt;&lt; accumulate(iv.begin(), iv.end(), int(1),
                                        multiplies&lt;int&gt;()) &lt;&lt;
        endl;

    return(0);
}

</pre>

    </ul>

<p><br><a name="l145"></a>
<h3>10.3.2: adjacent_difference()</h3>
    <a name="stl/adjacentdifference"></a>
        <ul>
        <li > Header file: 
        <pre>
#include&lt;numeric&gt;
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>OutpuIterator adjacent_difference(InputIterator first,
InputIterator last, OutputIterator result);</code>
            <li ><code>OutpuIterator adjacent_difference(InputIterator first,
InputIterator last, OutputIterator result, BinaryOperation op);</code>
        </ul>
        <li > Description:
        <ul>
            <li > The first prototype: The first returned element is equal to
the first element of the input range. The remaining returned elements are
equal to the difference of the corresponding element in the input range and
its previous element.
            <li > The second prototype: The first returned element is equal to
the first element of the input range. The remaining returned elements are
equal to the result of the binary operator <code>op</code> applied to the 
corresponding element in the input range (left operand) and its previous
element (right operand). 
        </ul>
        <li > Example:
        <pre>
#include&lt;numeric&gt;
#include&lt;vector&gt;
#include&lt;iostream&gt;

int main()
{
    int
        ia[] = {1, 2, 5, 10};
    vector&lt;int&gt;
        iv(ia, ia + 4),
        ov(iv.size());

    adjacent_difference(iv.begin(), iv.end(), ov.begin());
    copy(ov.begin(), ov.end(), ostream_iterator&lt;int&gt;(cout, " "));
    cout &lt;&lt; endl;

    adjacent_difference(iv.begin(), iv.end(), ov.begin(), minus&lt;int&gt;());
    copy(ov.begin(), ov.end(), ostream_iterator&lt;int&gt;(cout, " "));
    cout &lt;&lt; endl;

    return(0);
}

</pre>

    </ul>

<p><br><a name="l146"></a>
<h3>10.3.3: adjacent_find()</h3>
    <a name="stl/adjacentfind"></a>
        <ul>
        <li > Header file: 
        <pre>
#include&lt;algorithm&gt;
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>ForwardIterator adjacent_find(ForwardIterator first,
ForwardIterator last);</code>
            <li ><code>OutpuIterator adjacent_find(ForwardIterator first,
ForwardIterator last, Predicate pred);</code>
        </ul>
        <li > Description:
        <ul>
            <li > The first prototype: The iterator pointing to the first
element of the first set of two adjacent equal elements is returned. If no such
element exists, <code>last</code> is returned.
            <li > The second prototype: The iterator pointing to the first
element of the first set of two adjacent elements for which the binary
predicate <code>pred</code> returns <code>true</code> is returned. If no such element exists,
<code>last</code> is returned.
        </ul>
        <li > Example (see section <a href="cplusplus10.html#COPY">10.3.5</a> for a description of the
<code>copy()</code> generic algorithm that is used in the following example):
        <pre>
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;iostream&gt;

class SquaresDiff
{
    public:
        SquaresDiff(unsigned minimum): minimum(minimum)
        {}
        bool operator()(unsigned first, unsigned second)
        {
            return (second * second - first * first  &gt;= minimum);
        }
    private:
        unsigned
            minimum;
};
    
        
int main()
{
    string
        sarr[] =
        {
            "Alpha", "bravo", "charley", "echo", "echo", "delta", 
            "foxtrot", "golf"
        };
    string
        *last = sarr + sizeof(sarr) / sizeof(string),
        *result = adjacent_find(sarr, last);

    cout &lt;&lt; *result &lt;&lt; endl;
    result = adjacent_find(++result, last);

    cout &lt;&lt; "Second time, starting from the next position:\n" &lt;&lt;
        (
            result == last ?
                "** No more adjacent equal elements **"
            :
                "*result"
        ) &lt;&lt; endl;

    unsigned
        *ires,
        iv[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10},
        *ilast = iv + sizeof(iv) / sizeof(unsigned);


    ires = adjacent_find(iv, ilast, SquaresDiff(10));
    cout &lt;&lt; 
        "The first numbers for which the squares differ by at least 10 are: "
        &lt;&lt; *ires &lt;&lt; " and " &lt;&lt; *(ires + 1) &lt;&lt; endl;

    return(0);
}

</pre>

    </ul>

<p><br><a name="l147"></a>
<h3>10.3.4: binary_search()</h3>
    <a name="stl/binarysearch"></a>
        <ul>
        <li > Header file: 
        <pre>
#include&lt;algorithm&gt;
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>bool binary_search(ForwardIterator first,
ForwardIterator last, Type const &amp;value);</code>
            <li ><code>bool binary_search(ForwardIterator first,
ForwardIterator last, Type const &amp;value, Comparator comp);</code>
        </ul>
        <li > Description:
        <ul>
            <li > The first prototype: <code>value</code> is looked up using binary
search in the range of elements implied by the iterator range <code>[first,
last)</code>. The elements in the range must have been sorted by the
<code>Type::operator&lt;()</code> function. ttTrue) is returned if the element was found,
<code>false</code> otherwise.
            <li > The second prototype: <code>value</code> is looked up using binary
search in the range of elements implied by the iterator range <code>[first,
last)</code>. The elements in the range must have been sorted by the
<code>Comparator</code> function object. ttTrue) is returned if the element was found,
<code>false</code> otherwise.
        </ul>
        <li > Example:
        <pre>
#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;functional&gt;

int main()
{
    string
        sarr[] =
        {
            "Alpha", "bravo", "charley", "echo", "delta", 
            "foxtrot", "golf", "hotel"
        };
    string
        *last = sarr + sizeof(sarr) / sizeof(string);
    bool
        result = binary_search(sarr, last, "foxtrot");
    cout &lt;&lt; (result ? "found " : "didn't find ") &lt;&lt; "foxtrot" &lt;&lt; endl;

    reverse(sarr, last);                // reverse the order of elements
                                        // binary search now fails:
    result = binary_search(sarr, last, "foxtrot");
    cout &lt;&lt; (result ? "found " : "didn't find ") &lt;&lt; "foxtrot" &lt;&lt; endl;
                                        // ok when using appropriate
                                        // comparator:
    result = binary_search(sarr, last, "foxtrot", greater&lt;string&gt;());
    cout &lt;&lt; (result ? "found " : "didn't find ") &lt;&lt; "foxtrot" &lt;&lt; endl;


    return(0);
}

</pre>

    </ul>
<p><br>
<p><br>
    <a name="COPY"></a><a name="l148"></a>
<h3>10.3.5: copy()</h3>
    <a name="stl/copy"></a>
        <ul>
        <li > Header file: 
        <pre>
#include&lt;algorithm&gt;
</pre>

        <li > Function prototype:
        <ul>
            <li ><code>OutputIterator copy(InputIterator first,
InputIterator last, OutputIterator destination);</code>
        </ul>
        <li > Description:
        <ul>
            <li > The range of elements implied by the iterator range
<code>[first, last)</code> are copied to an output range, starting at
<code>destination</code>, using the assignment operator of the underlying data
type. The returnvalue is the OutputIterator pointing just beyond the last
element that was copied to the destinatin range (so, `last' in the destination
range is returned). In the example, note the second call to <code>copy()</code>. It
uses an <code>ostream_iterator</code> for <code>string</code> objects. This iterator will write
the <code>string</code> values to the specified <code>ostream</code> (i.e., <code>cout</code>),
separating the values by the specified separation string (i.e., <code>" "</code>).
        </ul>
        <li > Example:
        <pre>
#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;

int main()
{
    string
        sarr[] =
        {
            "Alpha", "bravo", "charley", "echo", "delta", 
            "foxtrot", "golf", "hotel"
        };
    string
        *last = sarr + sizeof(sarr) / sizeof(string);

    copy(sarr + 2, last, sarr);     // move all elements two positions left

                                    // copy to cout using an ostream_iterator
                                    // for strings,  
    copy(sarr, last, ostream_iterator&lt;string&gt;(cout, " "));
    cout &lt;&lt; endl;

    return(0);
}

</pre>

    </ul>

<p><br><a name="l149"></a>
<h3>10.3.6: copy_backward()</h3>
    <a name="stl/copybackward"></a>
        <ul>
        <li > Header file: 
        <pre>
#include&lt;algorithm&gt;
</pre>

        <li > Function prototype:
        <ul>
            <li ><code>BidirectionalIterator copy_backward(InputIterator first,
InputIterator last, BidirectionalIterator last2);</code>
        </ul>
        <li > Description:
        <ul>
            <li > The range of elements implied by the iterator range
<code>[first, last)</code> are copied from the element at position <code>last - 1</code>
until (and including) the element at position <code>first</code> to the element range,
<em>ending</em> at position <code>last2 - 1</code>, using the assignment operator of the
underlying data type. The destination range is therefore <code>[last2 - (last
- first), last2)</code>.
<p><br>The returnvalue is the BidirectionalIterator pointing at the last element that
was copied to the destinatin range (so, `first' in the destination range, pointed to by <code>last2 - (last - first)</code>, is returned).
        </ul>
        <li > Example:
        <pre>
#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;

int main()
{
    string
        sarr[] =
        {
            "Alpha", "bravo", "charley", "echo", "delta", 
            "foxtrot", "golf", "hotel"
        };
    string
        *last = sarr + sizeof(sarr) / sizeof(string);

    copy
    (
        copy_backward(sarr + 3, last, last - 3), 
        last, 
        ostream_iterator&lt;string&gt;(cout, " ")
    );
    cout &lt;&lt; endl;

    return(0);
}

</pre>

    </ul>
<p><br>
<p><br><a name="l150"></a>
<h3>10.3.7: count()</h3>
    <a name="stl/count"></a>
        <ul>
        <li > Header file: 
        <pre>
#include&lt;algorithm&gt;
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>size_t cout(InputIterator first, InputIterator last, Type
const &amp;value);</code>
        </ul>
        <li > Description:
        <ul>
            <li > The number of times <code>value</code> occurs in the
iterator range <code>first, last</code> is returned. To determine wheter <code>value</code> is
equal to an element in the iterator range <code>Type::operator==()</code> is used.
        </ul>
        <li > Example:
        <pre>
#include&lt;algorithm&gt;
#include&lt;iostream&gt;

int main()
{
    int
        ia[] = {1, 2, 3, 4, 3, 4, 2, 1, 3};

    cout &lt;&lt; "Number of times the value 3 is available: " &lt;&lt;
        count(ia, ia + sizeof(ia) / sizeof(int), 3) &lt;&lt;
        endl;

    return(0);
}

</pre>

    </ul>

<p><br><a name="l151"></a>
<h3>10.3.8: count_if()</h3>
    <a name="stl/countif"></a>
        <ul>
        <li > Header file: 
        <pre>
#include&lt;algorithm&gt;
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>size_t cout_if(InputIterator first, InputIterator last,
Predicate predicate);</code>
        </ul>
        <li > Description:
        <ul>
            <li > The number of times unary predicate <code>predicate</code> returns
<code>true</code> when applied to the elements implied by the iterator range <code>first,
last</code> is returned.
        </ul>
        <li > Example:
        <pre>
#include&lt;algorithm&gt;
#include&lt;iostream&gt;

class Odd
{
    public:
        bool operator()(int value)
        {
            return (value &amp; 1);
        }
};

int main()
{
    int
        ia[] = {1, 2, 3, 4, 3, 4, 2, 1, 3};

    cout &lt;&lt; "The number of odd values in the array is: " &lt;&lt; 
        count_if(ia, ia + sizeof(ia) / sizeof(int), Odd()) &lt;&lt;
        endl;

    return(0);
}

</pre>

    </ul>

<p><br><a name="l152"></a>
<h3>10.3.9: equal()</h3>
    <a name="stl/equal"></a>
        <ul>
        <li > Header file: 
        <pre>
#include&lt;algorithm&gt;
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>bool equal(InputIterator first, InputIterator last,
InputIterator otherFirst);</code>
            <li ><code>bool equal(InputIterator first, InputIterator last,
InputIterator otherFirst, BinaryPredicate pred);</code>
        </ul>
        <li > Description:
        <ul>
            <li > The first prototype: The elements in the range <code>[first,
last)</code> are compared to a range of equal length starting at <code>otherFirst</code>. The
function returns <code>true</code> if the visited elements in both ranges are equal
pairwise. The ranges need not be of equal length, only the elements in the
indicated range are considered (and must be available). 
            <li > The second prototype: The elements in the range
<code>[first, last)</code> are compared to a range of equal length starting at
<code>otherFirst</code>. The function returns <code>true</code> if the binary predicate, applied
to all corresponding elements in both ranges returns <code>true</code> for every pair
of corresponsing elements.  The ranges need not be of equal length, only the
elements in the indicated range are considered (and must be available).
        </ul>
        <li > Example:
        <pre>
#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;

class CaseString
{
    public:
        operator()(string const &amp;first, string const &amp;second) const
        {
            return (!strcasecmp(first.c_str(), second.c_str()));
        }
};

int main()
{
    string
        first[] =
        {
            "Alpha", "bravo", "Charley", "echo", "Delta", 
            "foxtrot", "Golf", "hotel"
        },
        second[] =
        {
            "alpha", "bravo", "charley", "echo", "delta", 
            "foxtrot", "golf", "hotel"
        };
    string
        *last = first + sizeof(first) / sizeof(string);

    cout &lt;&lt; "The elements of `first' and `second' are pairwise " &lt;&lt;
        (equal(first, last, second) ? "equal" : "not equal") &lt;&lt;
        endl &lt;&lt;
        "compared case-insensitively, they are " &lt;&lt;
        (equal(first, last, second, CaseString()) ? "equal" : "not equal") &lt;&lt;
        endl;

    return(0);
}

</pre>

    </ul>
<p><br>
<p><br><a name="l153"></a>
<h3>10.3.10: equal_range()</h3>
    <a name="stl/equalrange"></a>
        <ul>
        <li > Header files: 
        <pre>

        #include&lt;algorithm&gt;
        
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>pair&lt;ForwardIterator, ForwardIterator&gt;
equal_range(ForwardIterator first, ForwardIterator last, Type const &amp;value);</code> 
            <li ><code>pair&lt;ForwardIterator, ForwardIterator&gt;
equal_range(ForwardIterator first, ForwardIterator last, Type const &amp;value,
Compare comp);</code> 
        </ul>
        <li > Description:
        <ul>
            <li > The first prototype: Starting from a sorted sequence (where
the <code>operator&lt;()</code> of the underlying data type was used to sort the elements
in the provided range), a pair of iterators representing the returnvalue of,
respectively, <a href="LOWERBOUND">lower_bound()</a> and
<a href="UPPERBOUND">upper_bound()</a>is returned.
            <li > The second prototype: Starting from a sorted sequence (where
the <code>comp</code> function object was used to sort the elements
in the provided range), a pair of iterators representing the returnvalue of,
respectively, <a href="LOWERBOUND">lower_bound()</a> and
<a href="UPPERBOUND">upper_bound()</a>is returned.
        </ul>
        <li > Example:
        <pre>
#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;

int main()
{
    int
        range[] = {1, 3, 5, 7, 7, 9, 9, 9};
    unsigned const
        size = sizeof(range) / sizeof(int);

    pair&lt;int *, int *&gt;
        pi;

    pi = equal_range(range, range + size, 7);

    cout &lt;&lt; "Lower bound for 7: ";
    copy(pi.first, range + size, ostream_iterator&lt;int&gt;(cout, " "));
    cout &lt;&lt; endl;

    cout &lt;&lt; "Upper bound for 7: ";
    copy(pi.second, range + size, ostream_iterator&lt;int&gt;(cout, " "));
    cout &lt;&lt; endl;

    sort(range, range + size, greater&lt;int&gt;());

    cout &lt;&lt; "Sorted in descending order\n";

    copy(range, range + size, ostream_iterator&lt;int&gt;(cout, " "));
    cout &lt;&lt; endl;

    pi = equal_range(range, range + size, 7, greater&lt;int&gt;());

    cout &lt;&lt; "Lower bound for 7: ";
    copy(pi.first, range + size, ostream_iterator&lt;int&gt;(cout, " "));
    cout &lt;&lt; endl;

    cout &lt;&lt; "Upper bound for 7: ";
    copy(pi.second, range + size, ostream_iterator&lt;int&gt;(cout, " "));
    cout &lt;&lt; endl;


    return (0);
}

</pre>

    </ul>

<p><br><a name="l154"></a>
<h3>10.3.11: fill()</h3>
    <a name="stl/fill"></a>
        <ul>
        <li > Header file: 
        <pre>
#include&lt;algorithm&gt;
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>void fill(ForwardIterator first, ForwardIterator last, Type
                const &amp;value);</code>
        </ul>
        <li > Description:
        <ul>
            <li > all the elements implied by the interator range
<code>[first, last)</code> are initialized to <code>value</code>, overwriting the previous
values stored in the range.
        </ul>
        <li > Example:
        <pre>
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;iostream&gt;
#include&lt;iterator&gt;

int main()
{
    vector&lt;int&gt;
        iv(8);

    fill(iv.begin(), iv.end(), 8);

    copy(iv.begin(), iv.end(), ostream_iterator&lt;int&gt;(cout, " "));
    cout &lt;&lt; endl;

    return(0);
}

</pre>

    </ul>

<p><br><a name="l155"></a>
<h3>10.3.12: fill_n()</h3>
    <a name="stl/filln"></a>
        <ul>
        <li > Header file: 
        <pre>
#include&lt;algorithm&gt;
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>void fill_n(ForwardIterator first, Size n, Type
                const &amp;value);</code>
        </ul>
        <li > Description:
        <ul>
            <li > <code>n</code> elements starting at the element pointed to by
<code>first</code> are  initialized to <code>value</code>, overwriting the previous
values stored in the range.
        </ul>
        <li > Example:
        <pre>
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;iostream&gt;
#include&lt;iterator&gt;

int main()
{
    vector&lt;int&gt;
        iv(8);

    fill_n(iv.begin(), 8, 8);

    copy(iv.begin(), iv.end(), ostream_iterator&lt;int&gt;(cout, " "));
    cout &lt;&lt; endl;

    return(0);
}

</pre>
    
    </ul>

<p><br><a name="l156"></a>
<h3>10.3.13: find()</h3>
    <a name="stl/find"></a>
        <ul>
        <li > Header file: 
        <pre>
#include&lt;algorithm&gt;
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>InputIterator find(InputIterator first, 
    InputIterator last, Type const &amp;value);</code>
        </ul>
        <li > Description:
        <ul>
            <li > Element <code>value</code> is searched for in the range of the elements
implied by the interator range <code>[first, last)</code>. An iterator pointing to 
the first element found is returned. If the element was not found, <code>last</code> is
returned. The <code>operator==()</code> of the underlying data type is used to
compare the elements.
        </ul>
        <li > Example:
        <pre>
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;iostream&gt;
#include&lt;iterator&gt;

int main()
{
    string
        sarr[] =
        {
            "alpha", "bravo", "charley", "echo", "delta", 
            "foxtrot", "golf", "hotel"
        };
    string
        *last = sarr + sizeof(sarr) / sizeof(string);

    copy
    (   
        find(sarr, last, "echo"), last, ostream_iterator&lt;string&gt;(cout, " ")
    );
    cout &lt;&lt; endl;

    if (find(sarr, last, "india") == last)
    {
        cout &lt;&lt; "`india' was not found in the range\n";
        copy(sarr, last, ostream_iterator&lt;string&gt;(cout, " "));
        cout &lt;&lt; endl;
    }

    return(0);
}

</pre>

    </ul>

<p><br><a name="l157"></a>
<h3>10.3.14: find_if()</h3>
    <a name="stl/findif"></a>
        <ul>
        <li > Header file: 
        <pre>
#include&lt;algorithm&gt;
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>InputIterator find_if(InputIterator first, 
    InputIterator last, Prdicate pred);</code>
        </ul>
        <li > Description:
        <ul>
            <li > An iterator pointing to the first element in the range
implied by the interator range <code>[first, last)</code> for which the (unary)
predicate <code>pred</code> returns <code>true</code> is returned. If the element was not found,
<code>last</code> is returned.
        </ul>
        <li > Example:
        <pre>
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;iostream&gt;
#include&lt;iterator&gt;

class CaseName
{
    public:
        CaseName(char const *str): _string(str)
        {}
        bool operator()(string const &amp;element)
        {
            return (!strcasecmp(element.c_str(), _string.c_str()));
        }
    private:
        string
            _string;
};


int main()
{
    string
        sarr[] =
        {
            "Alpha", "Bravo", "Charley", "Echo", "Delta", 
            "Foxtrot", "Golf", "Hotel"
        };
    string
        *last = sarr + sizeof(sarr) / sizeof(string);

    copy
    (   
        find_if(sarr, last, CaseName("foxtrot")), 
        last, ostream_iterator&lt;string&gt;(cout, " ")
    );
    cout &lt;&lt; endl;

    if (find_if(sarr, last, CaseName("india")) == last)
    {
        cout &lt;&lt; "`india' was not found in the range\n";
        copy(sarr, last, ostream_iterator&lt;string&gt;(cout, " "));
        cout &lt;&lt; endl;
    }

    return(0);
}

</pre>

    </ul>

<p><br><a name="l158"></a>
<h3>10.3.15: find_end()</h3>
    <a name="stl/findend"></a>
        <ul>
        <li > Header file: 
        <pre>
#include&lt;algorithm&gt;
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>ForwardIterator1 find_end(ForwardIterator1 first1, 
    ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2)</code>
            <li ><code>ForwardIterator1 find_end(ForwardIterator1 first1, 
    ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2,
    BinaryPredicate pred)</code>
        </ul>
        <li > Description:
        <ul>
            <li > The first prototype: The sequence of elements implied by
<code>[first1, last1)</code> is searched for the last occurrence of the sequence of
elements implied by <code>[first2, last2)</code>. If the sequence <code>[first2,
last2)</code> is not found, <code>last1</code> is returned, otherwise an iterator pointing to
the first element of the matching sequence is returned. The <code>operator==()</code>
of the underlying data type is used to compare the elements in the two
sequences.
            <li > The second prototype: The sequence of elements implied by
<code>[first1, last1)</code> is searched for the last occurrence of the sequence of
elements implied by <code>[first2, last2)</code>. If the sequence <code>[first2,
last2)</code> is not found, <code>last1</code> is returned, otherwise an iterator pointing to
the first element of the matching sequence is returned. The provided binary
predicate is used to compare the elements in the two sequences.
        </ul>
        <li > Example:
        <pre>
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;iostream&gt;
#include&lt;iterator&gt;

class Twice
{
    public:
        bool operator()(unsigned first, unsigned second) const
        {
            return (first == (second &lt;&lt; 1));
        }
};

int main()
{
    string
        sarr[] =
        {
            "alpha", "bravo", "charley", "echo", "delta", 
            "foxtrot", "golf", "hotel",
            "foxtrot", "golf", "hotel",
            "india", "juliet", "kilo"
        },
        search[] = 
        {
            "foxtrot",
            "golf", 
            "hotel"
        };
    string
        *last = sarr + sizeof(sarr) / sizeof(string);

    copy
    (   
        find_end(sarr, last, search, search + 3),   // shows sequence starting
        last, ostream_iterator&lt;string&gt;(cout, " ")   // at 2nd 'foxtrot'
    );                                              
    cout &lt;&lt; endl;

    unsigned
        range[] = {2, 4, 6, 8, 10, 4, 6, 8, 10},
        nrs[]   = {2, 3, 4};


    copy                // show sequence of values starting at last sequence 
    (                   // of range[] that are twice the values in nrs[]
        find_end(range, range + 9, nrs, nrs + 3, Twice()), 
        range + 9, ostream_iterator&lt;unsigned&gt;(cout, " ")
    );                                              
    cout &lt;&lt; endl;

    return(0);
}




</pre>

    </ul>

<p><br><a name="l159"></a>
<h3>10.3.16: find_first_of()</h3>
    <a name="stl/findfirstof"></a>
        <ul>
        <li > Header file: 
        <pre>
#include&lt;algorithm&gt;
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>ForwardIterator1 find_first_of(ForwardIterator1 first1, 
    ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2)</code>
            <li ><code>ForwardIterator1 find_first_of(ForwardIterator1 first1, 
    ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2,
    BinaryPredicate pred)</code>
        </ul>
        <li > Description:
        <ul>
            <li > The first prototype: The sequence of elements implied by
<code>[first1, last1)</code> is searched for the first occurrence of an element in
the sequence of elements implied by <code>[first2, last2)</code>. If no element in
the sequence <code>[first2, last2)</code> is found, <code>last1</code> is returned, otherwise
an iterator pointing to the first element in <code>[first1, last1)</code> that is
equal to an element in <code>[first2, last2)</code> is returned. The
<code>operator==()</code> of the underlying data type is used to compare the elements
in the two sequences.
            <li > The second prototype: The sequence of elements implied by
<code>[first1, first1)</code> is searched for the first occurrence of an element in
the sequence of elements implied by <code>[first2, last2)</code>. Each element in
the range <code>[first1, last1)</code> is compared to each element in the range
<code>[first2, last2)</code>, and an iterator to the first element in
<code>[first1, last1)</code> for which the binary predicate <code>pred</code> (receiving an
the element out of the range <code>[first1, last1)</code> and an element from the
range <code>[first2, last2)</code>) returns <code>true</code> is returned. Otherwise,
<code>last1</code> is returned.
        </ul>
        <li > Example:
        <pre>
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;iostream&gt;
#include&lt;iterator&gt;

class Twice
{
    public:
        bool operator()(unsigned first, unsigned second) const
        {
            return (first == (second &lt;&lt; 1));
        }
};

int main()
{
    string
        sarr[] =
        {
            "alpha", "bravo", "charley", "echo", "delta", 
            "foxtrot", "golf", "hotel",
            "foxtrot", "golf", "hotel",
            "india", "juliet", "kilo"
        },
        search[] = 
        {
            "foxtrot",
            "golf", 
            "hotel"
        };
    string
        *last = sarr + sizeof(sarr) / sizeof(string);

    copy
    (                                               // shows sequence starting
        find_first_of(sarr, last, search, search + 3),  // at 1st 'foxtrot'
        last, ostream_iterator&lt;string&gt;(cout, " ")   
    );                                              
    cout &lt;&lt; endl;

    unsigned
        range[] = {2, 4, 6, 8, 10, 4, 6, 8, 10},
        nrs[]   = {2, 3, 4};


    copy                // show sequence of values starting at first sequence 
    (                   // of range[] that are twice the values in nrs[]
        find_first_of(range, range + 9, nrs, nrs + 3, Twice()), 
        range + 9, ostream_iterator&lt;unsigned&gt;(cout, " ")
    );                                              
    cout &lt;&lt; endl;

    return(0);
}




</pre>

    </ul>
<p><br>
<p><br><a name="l160"></a>
<h3>10.3.17: for_each()</h3>
    <a name="stl/foreach"></a>
        <ul>
        <li > Header file: 
        <pre>
#include&lt;algorithm&gt;
</pre>

        <li > Function prototype:
        <ul>
            <li ><code>Function for_each(InputIterator first,
    InputIterator last, Function func);</code>
        </ul>
        <li > Description:
        <ul>
            <li > Each of the elements implied by the iterator range
<code>[first, last)</code> is passed in turn to the <em>function</em> <code>func</code>. The
function may not modify the elements it receives (as the used iterator is an
input iterator). If the elements are to be transformed, <code>transform()</code> (see
section <a href="cplusplus10.html#TRANSFORM">10.3.63</a>) should be used. The function object is returned: see
te example below, in which an extra argument list is added to the
<code>for_each()</code> call, which argument is eventually also passed to the function
given to <code>for_each()</code>. Within <code>for_each()</code> the returnvalue of the function
that is passed to it is ignored.
        </ul>
        <li > Example:
        <pre>
#include&lt;algorithm&gt;
#include&lt;string&gt;
#include&lt;iostream&gt;

void capitalizedOutput(string const &amp;str)
{
    char
        *tmp = strcpy(new char[str.size() + 1], str.c_str());

                            // can't use for_each here, 
                            // as 'tmp' is modified
    transform(tmp + 1, tmp + str.size(), tmp + 1, tolower);

    tmp[0] = toupper(*tmp);
    cout &lt;&lt; tmp &lt;&lt; " ";
    delete tmp;
};

int main()
{
    string
        sarr[] =
        {
            "alpha", "BRAVO", "charley", "ECHO", "delta", 
            "FOXTROT", "golf", "HOTEL", 
        },
        *last = sarr + sizeof(sarr) / sizeof(string);

    for_each(sarr, last, capitalizedOutput)("that's all, folks");
    cout &lt;&lt; endl;

    return(0);
}




</pre>

    </ul>

<p><br><a name="l161"></a>
<h3>10.3.18: generate()</h3>
    <a name="stl/generate"></a>
        <ul>
        <li > Header file: 
        <pre>
#include&lt;algorithm&gt;
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>void generate(ForwardIterator first, ForwardIterator last, 
                Generator generator);</code>
        </ul>
        <li > Description:
        <ul>
            <li > all the elements implied by the interator range
<code>[first, last)</code> are initialized by the returnvalue of <code>generator</code>,
which can be a function or function object.
        </ul>
        <li > Example:
        <pre>
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;iostream&gt;
#include&lt;iterator&gt;

class NaturalSquares
{
    public:
        NaturalSquares(): newsqr(0), last(0)
        {}    
        unsigned operator()()
        {                                       // (a + 1)^2 == a^2 + 2*a + 1
            return (newsqr += (last++ &lt;&lt; 1) + 1);
        }

    private:
        unsigned
            newsqr,
            last;
};

int main()
{
    vector&lt;unsigned&gt;
        uv(10);

    generate(uv.begin(), uv.end(), NaturalSquares());

    copy(uv.begin(), uv.end(), ostream_iterator&lt;int&gt;(cout, " "));
    cout &lt;&lt; endl;

    return(0);
}

</pre>

    </ul>

<p><br><a name="l162"></a>
<h3>10.3.19: generate_n()</h3>
    <a name="stl/generaten"></a>
        <ul>
        <li > Header file: 
        <pre>
#include&lt;algorithm&gt;
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>void generate_n(ForwardIterator first, Size n
                Generator generator);</code>
        </ul>
        <li > Description:
        <ul>
            <li > <code>n</code> elements starting at the element pointed to by 
interator <code>first</code> are initialized by the returnvalue of <code>generator</code>,
which can be a function or function object.
        </ul>
        <li > Example:
        <pre>
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;iostream&gt;
#include&lt;iterator&gt;

class NaturalSquares
{
    public:
        NaturalSquares(): newsqr(0), last(0)
        {}    
        unsigned operator()()
        {                                       // (a + 1)^2 == a^2 + 2*a + 1
            return (newsqr += (last++ &lt;&lt; 1) + 1);
        }

    private:
        unsigned
            newsqr,
            last;
};

int main()
{
    vector&lt;unsigned&gt;
        uv(10);

    generate_n(uv.begin(), 10, NaturalSquares());

    copy(uv.begin(), uv.end(), ostream_iterator&lt;int&gt;(cout, " "));
    cout &lt;&lt; endl;

    return(0);
}

</pre>

    </ul>

<p><br><a name="l163"></a>
<h3>10.3.20: includes()</h3>
    <a name="stl/includes"></a>
        <ul>
        <li > Header files: 
        <pre>

        #include&lt;algorithm&gt;
        
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>bool includes(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2);</code>
            <li ><code>bool includes(InputIterator1 first1, InputIterator1 last1,
InputIterator2 first2, InputIterator2 last2, Compare comp);</code>
        </ul>
        <li > Description:
        <ul>
            <li > The first prototype: Both sequences of elements implied by
the ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> should be
sorted, using the <code>operator&lt;()</code> of the underlying datatype. The function
returns <code>true</code> if every element in the second sequence (<code>[first1,
second1)</code> is contained in the first sequence (<code>[first2, second2)</code>) (the
second range is a subset of the first range). 
            <li > The second prototype: Both sequences of elements implied by
the ranges <code>[first1, last1)</code> and <code>[first2, last2)</code> should be sorted,
using the <code>comp</code> function object. The function returns <code>true</code> if every
element in the second sequence (<code>[first1, second1)</code> is contained in the
first seqence (<code>[first2, second2)</code>) (the second range is a subset of the
first range).
        </ul>
        <li > Example:
        <pre>
#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;

class CaseString
{
    public:
        operator()(string const &amp;first, string const &amp;second) const
        {
            return (!strcasecmp(first.c_str(), second.c_str()));
        }
};

int main()
{
    string
        first1[] =
        {
            "alpha", "bravo", "charley", "echo", "delta", 
            "foxtrot", "golf", "hotel"
        },
        first2[] =
        {
            "Alpha", "bravo", "Charley", "echo", "Delta", 
            "foxtrot", "Golf", "hotel"
        },
        second[] = 
        {
            "charley", "foxtrot", "hotel"
        };
    unsigned
        n = sizeof(first1) / sizeof(string);

    cout &lt;&lt; "The elements of `second' are " &lt;&lt;
        (includes(first1, first1 + n, second, second + 3) ? "" : "not") 
        &lt;&lt; " contained in the first sequence: second is a subset of first1\n";

    cout &lt;&lt; "The elements of `first1' are " &lt;&lt;
        (includes(second, second + 3, first1, first1 + n) ? "" : "not") 
        &lt;&lt; " contained in the second sequence\n";

    cout &lt;&lt; "The elements of `second' are " &lt;&lt;
        (includes(first2, first2 + n, second, second + 3) ? "" : "not") 
        &lt;&lt; " contained in the first2 sequence\n";

    cout &lt;&lt; "Using case-insensitive comparison,\n"
        "the elements of `second' are " 
        &lt;&lt; 
        (includes(first2, first2 + n, second, second + 3, CaseString()) ? 
            "" : "not") 
        &lt;&lt; " contained in the first2 sequence\n";

    return(0);
}

</pre>

    </ul>

<p><br><a name="l164"></a>
<h3>10.3.21: inner_product()</h3>
    <a name="stl/innerproduct"></a>
        <ul>
        <li > Header files: 
        <pre>

        #include&lt;algorithm&gt;
        
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>Type inner_product(InputIterator1 first1, InputIterator1
last1, InputIterator2 first2, Type init);</code>
            <li ><code>Type inner_product(InputIterator1 first1, InputIterator1
last1, InputIterator2 first2, Type init,
BinaryOperator1 op1, BinaryOperator2 op2);</code>
        </ul>
        <li > Description:
        <ul>
            <li > The first prototype: The sum of all pairwise products of the
elements implied by the range <code>[first1, last1)</code> and the same number of
elements starting at the element pointed to by <code>first2</code>
are added to <code>init</code>, and this sum is returned. The function uses the
<code>operator+()</code> and <code>operator*()</code> of the underlying datatype.
            <li > The second prototype: Binary operator <code>op2</code> instead of the
default addition operator, and binary operator <code>op1</code> instead of the default
multiplication operator are applied to all pairwise elements implied by the
range <code>[first1, last1)</code> and the same number of elements starting at the
element pointed to by <code>first2</code>. The final result is returned.
        </ul>
        <li > Example:
        <pre>
#include &lt;numeric&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

class Cat
{
    public:
        Cat(string const &amp;sep): sep(sep)
        {}
        string operator()(string const &amp;s1, string const &amp;s2)
        {
            return (s1 + sep + s2);
        }
    private:
        string
            sep;
};

int main()
{
    unsigned
        ia1[] = {1, 2, 3, 4, 5, 6, 7},
        ia2[] = {7, 6, 5, 4, 3, 2, 1},
        init = 0;

    cout &lt;&lt; "The sum of all squares in ";
    copy(ia1, ia1 + 7, ostream_iterator&lt;unsigned&gt;(cout, " "));
    cout &lt;&lt; "is " &lt;&lt; 
        inner_product(ia1, ia1 + 7, ia1, init) &lt;&lt; endl;

    cout &lt;&lt; "The sum of all cross-products in ";
    copy(ia1, ia1 + 7, ostream_iterator&lt;unsigned&gt;(cout, " "));
    cout &lt;&lt; " and ";
    copy(ia2, ia2 + 7, ostream_iterator&lt;unsigned&gt;(cout, " "));
    cout &lt;&lt; "is " &lt;&lt; 
        inner_product(ia1, ia1 + 7, ia2, init) &lt;&lt; endl;

    string
        names1[] = {"Frank", "Karel", "Piet"},
        names2[] = {"Brokken", "Kubat", "Plomp"};

    cout &lt;&lt; "A list of all combined names in ";
    copy(names1, names1 + 3, ostream_iterator&lt;string&gt;(cout, " "));
    cout &lt;&lt; "and ";
    copy(names2, names2 + 3, ostream_iterator&lt;string&gt;(cout, " "));
    cout &lt;&lt; "is:" &lt;&lt;
        inner_product(names1, names1 + 3, names2, string("\t"), 
            Cat("\n\t"), Cat(" ")) &lt;&lt; 
        endl;

    return(0);
}


</pre>

    </ul>

<p><br><a name="l165"></a>
<h3>10.3.22: inplace_merge()</h3>
    <a name="stl/inplacemerge"></a>
        <ul>
        <li > Header files: 
        <pre>

        #include&lt;algorithm&gt;
        
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>void inplace_merge(BidirectionalIterator first,
BidirectionalIterator middle, BidirectionalIterator last);</code>
            <li ><code>void inplace_merge(BidirectionalIterator first,
BidirectionalIterator middle, BidirectionalIterator last, Compare comp);</code>
        </ul>
        <li > Description:
        <ul>
            <li > The first prototype: The two (sorted) ranges <code>[first,
middle)</code> and <code>[middle, last)</code> are merged, keeping a sorted list (using the
<code>operator&lt;()</code> of the underlying data type). The final series is stored in
the range <code>[first, last)</code>.
            <li > The second prototype: The two (sorted) ranges <code>[first,
middle)</code> and <code>[middle, last)</code> are merged, keeping a sorted list (using the
boolean result of the binaray comparison operator <code>comp</code>). The final series
is stored in the range <code>[first, last)</code>.
        </ul>
        <li > Example:
        <pre>
#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;

class CaseString
{
    public:
        operator()(string const &amp;first, string const &amp;second) const
        {
            return (strcasecmp(first.c_str(), second.c_str()) &lt; 0);
        }
};

int main()
{
    string
        range[] =
        {
            "alpha", "charley", "delta", "foxtrot", "hotel"
            "bravo", "echo", "golf"
        };

    inplace_merge(range, range + 5, range + 8);
    copy(range, range + 8, ostream_iterator&lt;string&gt;(cout, " "));
    cout &lt;&lt; endl;

    string
        range2[] =
        {
            "ALFA", "CHARLEY", "DELTA", "foxtrot", "hotel"
            "bravo", "ECHO", "GOLF"
        };

    inplace_merge(range2, range2 + 5, range2 + 8, CaseString());
    copy(range2, range2 + 8, ostream_iterator&lt;string&gt;(cout, " "));
    cout &lt;&lt; endl;

    return(0);
}

</pre>

    </ul>
 
<p><br><a name="l166"></a>
<h3>10.3.23: iter_swap()</h3>
    <a name="stl/iterswap"></a>
        <ul>
        <li > Header file: 
        <pre>
#include&lt;algorithm&gt;
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>void iter_swap(ForwardIterator1 iter1, 
    ForwardIterator2 iter2);</code>
        </ul>
        <li > Description:
        <ul>
            <li > The elements pointed to by <code>iter1</code> and <code>iter2</code> are
swapped.
        </ul>
        <li > Example:
        <pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

int main()
{
    string
        first[] = {"alpha", "bravo", "charley", "delta", "echo", "delta"},
        second[] = {"echo", "foxtrot", "golf", "hotel", "india", "kilo"};
    unsigned
        n = sizeof(first) / sizeof(string);
    
    cout &lt;&lt; "Before:\n";
    copy(first, first + n, ostream_iterator&lt;string&gt;(cout, " "));
    cout &lt;&lt; endl;
    copy(second, second + n, ostream_iterator&lt;string&gt;(cout, " "));
    cout &lt;&lt; endl;

    for (unsigned idx = 0; idx &lt; n; ++idx)
        iter_swap(first + idx, second + idx);

    cout &lt;&lt; "After:\n";
    copy(first, first + n, ostream_iterator&lt;string&gt;(cout, " "));
    cout &lt;&lt; endl;
    copy(second, second + n, ostream_iterator&lt;string&gt;(cout, " "));
    cout &lt;&lt; endl;

    return (0);
}
</pre>

    </ul>

<p><br><a name="l167"></a>
<h3>10.3.24: lexicographical_compare()</h3>
    <a name="stl/lexicographicalcompare"></a>
        <ul>
        <li > Header files: 
        <pre>

        #include&lt;algorithm&gt;
        
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>bool lexicographical_compare(InputIterator1 first1,
InputIterator1 last1, InputIterator2 first2, InputIterator2 last2);</code>
            <li ><code>bool lexicographical_compare(InputIterator1 first1,
InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, Compare
comp);</code>
        </ul>
        <li > Description:
        <ul>
            <li > The first prototype: The corresponding pairs of elements in
the ranges pointed to by <code>[first1, last1)</code> and <code>[first2, last2)</code> are
compared. The function returns <code>true</code> 
            <ul>
                <li > at the first element in the first range which is less
than the corresponding element in the second range (using the <code>operator&lt;()</code>
of the underlying data type),
                <li > if <code>last1</code> is reached, but <code>last2</code> isn't reached yet.
            </ul>
False is returned in the other cases, which indicates that the first sequence
is not lexicographical less than the second sequence. I.e., <code>false</code> is
returned             
            <ul>
                <li > at the first element in the first range which is greater
than the corresponding element in the second range (using the <code>operator&lt;()</code>
of the underlying data type),
                <li > if <code>last2</code> is reached, but <code>last1</code> isn't reached yet.
                <li > if <code>last1</code> and <code>last2</code> are reached.
            </ul>
            <li > The second prototype: With this function the binary
comparison operation as defined by <code>comp</code> is used instead of the underlying
<code>operator&lt;()</code>.
        </ul>
        <li > Example:
        <pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

class CaseString
{
    public:
        operator()(string const &amp;first, string const &amp;second) const
        {
            return (strcasecmp(first.c_str(), second.c_str()) &lt; 0);
        }
};

int main()
{
    char const 
        word1[] = "help",
        word2[] = "hello";

    cout &lt;&lt; word1 &lt;&lt; " is " &lt;&lt;
        (
            lexicographical_compare(word1, word1 + strlen(word1),
                                    word2, word2 + strlen(word2)) ?
                "before "
            :
                "beyond or at "
        ) &lt;&lt;
        word2 &lt;&lt; " in the alphabet\n";
        
    cout &lt;&lt; word1 &lt;&lt; " is " &lt;&lt;
        (
            lexicographical_compare(word1, word1 + strlen(word1),
                                    word1, word1 + strlen(word1)) ?
                "before "
            :
                "beyond or at "
        ) &lt;&lt;
        word1 &lt;&lt; " in the alphabet\n";
        
    cout &lt;&lt; word2 &lt;&lt; " is " &lt;&lt;
        (
            lexicographical_compare(word2, word2 + strlen(word2),
                                    word1, word1 + strlen(word1)) ?
                "before "
            :
                "beyond or at "
        ) &lt;&lt;
        word1 &lt;&lt; " in the alphabet\n";
        
    string
        one[] = {"alpha", "bravo", "charley"},
        two[] = {"ALPHA", "BRAVO", "DELTA"};

    copy(one, one + 3, ostream_iterator&lt;string&gt;(cout, " "));
    cout &lt;&lt; " is ordered " &lt;&lt;
        (
            lexicographical_compare(one, one + 3,
                                    two, two + 3, CaseString()) ?
                "before "
            :
                "beyond or at "
        );
    copy(two, two + 3, ostream_iterator&lt;string&gt;(cout, " "));
    cout &lt;&lt; endl &lt;&lt;
        "using case-insensitive comparisons.\n";

    return (0);
}
</pre>

    </ul>

<p><br>
    <a name="LOWERBOUND"></a><a name="l168"></a>
<h3>10.3.25: lower_bound()</h3>
    <a name="stl/lowerbound"></a>
        <ul>
        <li > Header files: 
        <pre>

        #include&lt;algorithm&gt;
        
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>ForwardIterator lower_bound(ForwardIterator first, 
ForwardIterator last, const Type &amp;value);</code>
            <li ><code>ForwardIterator lower_bound(ForwardIterator first, 
ForwardIterator last, const Type &amp;value, Compare comp);</code>
        </ul>
        <li > Description:
        <ul>
            <li > The first prototype: The sorted elements implied by the
iterator range <code>[first, last)</code> are searched for the first element that
that is not less than (i.e., greater than or equal to) <code>value</code>. The returned
iterator marks the location in the sequence where <code>value</code> can be inserted
without breaking the sorted order of the elements. The <code>operator&lt;()</code> of the
underlying datatype is used. If no such element is found, <code>last</code> is
returned.
            <li > The second prototype: The elements implied by the iterator
range <code>[first, last)</code> must have been sorted using the <code>comp</code> function
(-object). Each element in the range is compared to <code>value</code> using the
<code>comp</code> function. An iterator to the first element for which the binary
predicate <code>comp</code>, applied to the elements of the range and <code>value</code>,
returns <code>false</code> is returned.  If no such element is found, <code>last</code> is
returned.
        </ul>
        <li > Example:
        <pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;functional&gt;

int main()
{
    int 
        ia[] = {10, 20, 30};

    cout &lt;&lt; "Sequence: ";
    copy(ia, ia + 3, ostream_iterator&lt;int&gt;(cout, " "));
    cout &lt;&lt; endl;

    cout &lt;&lt; "15 can be inserted before " &lt;&lt;
            *lower_bound(ia, ia + 3, 15) &lt;&lt; endl;
    cout &lt;&lt; "35 can be inserted after " &lt;&lt;
            (lower_bound(ia, ia + 3, 35) == ia + 3 ? 
                                "the last element" : "???") &lt;&lt; endl;

    iter_swap(ia, ia + 2);

    cout &lt;&lt; "Sequence: ";
    copy(ia, ia + 3, ostream_iterator&lt;int&gt;(cout, " "));
    cout &lt;&lt; endl;

    cout &lt;&lt; "15 can be inserted before " &lt;&lt;
            *lower_bound(ia, ia + 3, 15, greater&lt;int&gt;()) &lt;&lt; endl;
    cout &lt;&lt; "35 can be inserted before " &lt;&lt;
            (lower_bound(ia, ia + 3, 35, greater&lt;int&gt;()) == ia ? 
                                "the first element " : "???") &lt;&lt; endl;

    return (0);
}
</pre>

    </ul>

<p><br><a name="l169"></a>
<h3>10.3.26: max()</h3>
    <a name="stl/max"></a>
        <ul>
        <li > Header file: 
        <pre>
#include&lt;algorithm&gt;
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>Type const &amp;max(Type const &amp;one, Type const &amp;two);</code>
            <li ><code>Type const &amp;max(Type const &amp;one, Type const &amp;two, Comparator
                comp);</code> 
        </ul>
        <li > Description:
        <ul>
            <li > The first prototype: The larger of the two elements <code>one</code>
and <code>two</code> is returned, using the <code>operator&gt;()</code> of the underlying type.
            <li > The second prototype: <code>one</code> is returned if the binary
predicate <code>comp(one, two)</code> returns <code>true</code>, otherwise <code>two</code> is returned.
        </ul>
        <li > Example:
        <pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

class CaseString
{
    public:
        bool operator()(string const &amp;first, string const &amp;second) const
        {
            return (strcasecmp(second.c_str(), first.c_str()) &gt; 0);
        }
};


int main()
{
    cout &lt;&lt; "Word '" &lt;&lt; max(string("first"), string("second")) &lt;&lt; 
                                "' is lexicographically last\n";

    cout &lt;&lt; "Word '" &lt;&lt; max(string("first"), string("SECOND")) &lt;&lt; 
                                "' is lexicographically last\n";

    cout &lt;&lt; "Word '" &lt;&lt; max(string("first"), string("SECOND"), 
                        CaseString()) &lt;&lt; "' is lexicographically last\n";

    return (0);
}
</pre>

    </ul>

<p><br><a name="l170"></a>
<h3>10.3.27: max_element()</h3>
    <a name="stl/maxelement"></a>
        <ul>
        <li > Header file: 
        <pre>
#include&lt;algorithm&gt;
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>ForwardIterator max_element(ForwardIterator first, 
ForwardIterator last);</code>
            <li ><code>ForwardIterator max_element(ForwardIterator first, 
ForwardIterator last, Comparator comp);</code>
        </ul>
        <li > Description:
        <ul>
            <li > The first prototype: An iterator pointing to the largest
element in the range implied by <code>[first, last)</code> is returned. The
<code>operator&gt;()</code> of the underlying type is used.
            <li > The second prototype: rather than using <code>operator&gt;()</code>, the
binary predicate <code>comp</code> is used to make the comparisons between the elements
implied by the iterator range <code>[first, last)</code>. The element with which
<code>comp</code> returns most often <code>true</code> is returned.
        </ul>
        <li > Example:
        <pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;

class AbsValue
{
    public:
        bool operator()(int first, int second) const
        {
            return (abs(second) &gt; abs(first));
        }
};


int main()
{
    int
        ia[] = {-4, 7, -2, 10, -12};

    cout &lt;&lt; "The maximum int value is " &lt;&lt; *max_element(ia, ia + 5) &lt;&lt; endl;
    cout &lt;&lt; "The maximum absolute int value is " &lt;&lt; 
            *max_element(ia, ia + 5, AbsValue()) &lt;&lt; endl;

    return (0);
}
</pre>

    </ul>

<p><br><a name="l171"></a>
<h3>10.3.28: min()</h3>
    <a name="stl/min"></a>
        <ul>
        <li > Header file: 
        <pre>
#include&lt;algorithm&gt;
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>Type const &amp;min(Type const &amp;one, Type const &amp;two);</code>
            <li ><code>Type const &amp;min(Type const &amp;one, Type const &amp;two, Comparator
                comp);</code> 
        </ul>
        <li > Description:
        <ul>
            <li > The first prototype: The smaller of the two elements <code>one</code>
and <code>two</code> is returned, using the <code>operator&lt;()</code> of the underlying type.
            <li > The second prototype: <code>one</code> is returned if the binary
predicate <code>comp(one, two)</code> returns <code>false</code>, otherwise <code>two</code> is returned.
        </ul>
        <li > Example:
        <pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

class CaseString
{
    public:
        bool operator()(string const &amp;first, string const &amp;second) const
        {
            return (strcasecmp(second.c_str(), first.c_str()) &gt; 0);
        }
};


int main()
{
    cout &lt;&lt; "Word '" &lt;&lt; min(string("first"), string("second")) &lt;&lt; 
                                "' is lexicographically first\n";

    cout &lt;&lt; "Word '" &lt;&lt; min(string("first"), string("SECOND")) &lt;&lt; 
                                "' is lexicographically first\n";

    cout &lt;&lt; "Word '" &lt;&lt; min(string("first"), string("SECOND"), 
                        CaseString()) &lt;&lt; "' is lexicographically first\n";

    return (0);
}
</pre>

    </ul>

<p><br><a name="l172"></a>
<h3>10.3.29: min_element()</h3>
    <a name="stl/minelement"></a>
        <ul>
        <li > Header file: 
        <pre>
#include&lt;algorithm&gt;
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>ForwardIterator min_element(ForwardIterator first, 
ForwardIterator last);</code>
            <li ><code>ForwardIterator min_element(ForwardIterator first, 
ForwardIterator last, Comparator comp);</code>
        </ul>
        <li > Description:
        <ul>
            <li > The first prototype: An iterator pointing to the smallest
element in the range implied by <code>[first, last)</code> is returned. The
<code>operator&lt;()</code> of the underlying type is used.
            <li > The second prototype: rather than using <code>operator&lt;()</code>, the
binary predicate <code>comp</code> is used to make the comparisons between the elements
implied by the iterator range <code>[first, last)</code>. The element with which
<code>comp</code> returns most often <code>false</code> is returned.
        </ul>
        <li > Example:
        <pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;

class AbsValue
{
    public:
        bool operator()(int first, int second) const
        {
            return (abs(second) &gt; abs(first));
        }
};


int main()
{
    int
        ia[] = {-4, 7, -2, 10, -12};

    cout &lt;&lt; "The minimum int value is " &lt;&lt; *min_element(ia, ia + 5) &lt;&lt; endl;
    cout &lt;&lt; "The minimum absolute int value is " &lt;&lt; 
            *min_element(ia, ia + 5, AbsValue()) &lt;&lt; endl;

    return (0);
}
</pre>

    </ul>

<p><br><a name="l173"></a>
<h3>10.3.30: merge()</h3>
    <a name="stl/merge"></a>
        <ul>
        <li > Header files: 
        <pre>

        #include&lt;algorithm&gt;
        
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>OutputIterator merge(InputIterator1 first1,
InputIterator1 last1, InputIterator2 first2,
InputIterator2 last2, OutputIterator result);</code>
            <li ><code>OutputIterator merge(InputIterator1 first1,
InputIterator1 last1, InputIterator2 first2,
InputIterator2 last2, OutputIterator result, Compare comp);</code>
        </ul>
        <li > Description:
        <ul>
            <li > The first prototype: The two (sorted) ranges <code>[first,
middle)</code> and <code>[middle, last)</code> are merged, keeping a sorted list (using the
<code>operator&lt;()</code> of the underlying data type). The final series is stored in
the range starting at <code>result</code> and ending just before the OutputIterator
that is returned by the function.
            <li > The second prototype: The two (sorted) ranges <code>[first,
middle)</code> and <code>[middle, last)</code> are merged, keeping a sorted list (using the
boolean result of the binaray comparison operator <code>comp</code>). The final series
is stored in the range starting at <code>result</code> and ending just before the
OutputIterator that is returned by the function.
        </ul>
        <li > Example:
        <pre>
#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;

class CaseString
{
    public:
        operator()(string const &amp;first, string const &amp;second) const
        {
            return (strcasecmp(first.c_str(), second.c_str()) &lt; 0);
        }
};

int main()
{
    string
        range1[] =
        {
            "alpha", "bravo", "foxtrot", "hotel", "zulu"
        },
        range2[] =
        {
            "delta", "echo", "golf", "romeo"
        },
        result[5 + 4];

    
    copy(result, 
        merge(range1, range1 + 5, range2, range2 + 4, result),
        ostream_iterator&lt;string&gt;(cout, " "));
    cout &lt;&lt; endl;

    string
        range3[] =
        {
            "ALPHA", "bravo", "foxtrot", "HOTEL", "ZULU"
        },
        range4[] =
        {
            "delta", "ECHO", "GOLF", "romeo"
        };

    
    copy(result, 
        merge(range3, range3 + 5, range4, range4 + 4, result, CaseString()),
        ostream_iterator&lt;string&gt;(cout, " "));
    cout &lt;&lt; endl;

    return(0);
}


</pre>

    </ul>

<p><br><a name="l174"></a>
<h3>10.3.31: mismatch()</h3>
    <a name="stl/mismatch"></a>
        <ul>
        <li > Header files: 
        <pre>

        #include&lt;algorithm&gt;
        
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>pair&lt;InputIterator1, InputIterator2&gt; 
                mismatch(InputIterator1 first1, 
                InputIterator1 last1, InputIterator2 first2);</code>
            <li ><code>pair&lt;InputIterator1, InputIterator2&gt; 
                mismatch(InputIterator1 first1,
                InputIterator1 last1, InputIterator2 first2, 
                Compare comp);</code>
        </ul>
        <li > Description:
        <ul>
            <li > The first prototype: The two sequences of elements starting
at <code>first1</code> and <code>first2</code> are compared using the equality operator of the
underlying data type. Comparison stops if the compared elements differ (i.e.,
<code>operator==()</code> returns false) or <code>last1</code> is reached. A <code>pair</code> containing
iterators pointing to the final positions is returned. The second sequence may
contain more elements than the first sequence. The behavior of the algorithm
is undefined if the second sequence contains less elements than the first
sequence. 
            <li > The second prototype: The two sequences of elements starting
at <code>first1</code> and <code>first2</code> are compared using With this function the binary
comparison operation as defined by <code>comp</code> is used instead of the underlying
<code>operator==()</code>. Comparison stops if the <code>comp</code> function returns <code>false</code>
or <code>last1</code> is reached. A <code>pair</code> containing iterators pointing to the final
positions is returned. The second sequence may contain more elements than the
first sequence. The behavior of the algorithm is undefined if the second
sequence contains less elements than the first sequence.
        </ul>
        <li > Example:
        <pre>
#include &lt;algorithm&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;utility&gt;

class CaseString
{
    public:
        operator()(string const &amp;first, string const &amp;second) const
        {
            return (strcasecmp(first.c_str(), second.c_str()) == 0);
        }
};

int main()
{
    string
        range1[] =
        {
            "alpha", "bravo", "foxtrot", "hotel", "zulu"
        },
        range2[] =
        {
            "alpha", "bravo", "foxtrot", "Hotel", "zulu"
        };

    
    pair&lt;string *, string *&gt;
        pss = mismatch(range1, range1 + 5, range2);

    cout &lt;&lt; "The elements " &lt;&lt; *pss.first &lt;&lt; " and " &lt;&lt; *pss.second &lt;&lt;
            " at offset " &lt;&lt; (pss.first - range1) &lt;&lt; " differ\n";
    if 
    (
        mismatch(range1, range1 + 5, range2, CaseString()).first 
        == range1 + 5
    )
        cout &lt;&lt; "When compared case-insensitively they match\n";

    return(0);
}


</pre>

    </ul>

<p><br><a name="l175"></a>
<h3>10.3.32: next_permutation()</h3>
    <a name="stl/nextpermutation"></a>
        <ul>
        <li > Header files: 
        <pre>

        #include&lt;algorithm&gt;
        
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>bool next_permutation(BidirectionalIterator first,
                BidirectionalIterator last);</code>
            <li ><code>bool next_permutation(BidirectionalIterator first,
                BidirectionalIterator last, Comp comp);</code>
        </ul>
        <li > Description:
        <ul>
            <li > The first prototype: The next permutation given the sequence
of elements in the range <code>[first, last)</code> is determined. The elements in
the range are reordered. The value <code>true</code> is returned if a reordering took
place, the value <code>false</code> is returned if no reordering took place, which is
the case if the resulting sequence would haven been ordered, according to the
<code>operator&lt;()</code> of the underlying data type.
            <li > The second prototype: The next permutation given the sequence
of elements in the range <code>[first, last)</code> is determined. The elements in
the range are reordered. The value <code>true</code> is returned if a reordering took
place, the value <code>false</code> is returned if no reordering took place, which is
the case if the resulting sequence would haven been ordered, using the
binary predicate <code>comp</code> to compare two elements.
        </ul>
        <li > Example:
        <pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

class CaseString
{
    public:
        operator()(string const &amp;first, string const &amp;second) const
        {
            return (strcasecmp(first.c_str(), second.c_str()) &lt; 0);
        }
};

int main()
{
    string
        saints[] = {"Oh", "when", "the", "saints"};

    cout &lt;&lt; "All permutations of 'Oh when the saints':\n";

    cout &lt;&lt; "Sequences:\n";
    do
    {
        copy(saints, saints + 4, ostream_iterator&lt;string&gt;(cout, " "));
        cout &lt;&lt; endl;
    }
    while (next_permutation(saints, saints + 4, CaseString()));


    cout &lt;&lt; "After first sorting the sequence:\n";

    sort(saints, saints + 4, CaseString());

    cout &lt;&lt; "Sequences:\n";
    do
    {
        copy(saints, saints + 4, ostream_iterator&lt;string&gt;(cout, " "));
        cout &lt;&lt; endl;
    }
    while (next_permutation(saints, saints + 4, CaseString()));

    return (0);
}
</pre>

    </ul>

<p><br><a name="l176"></a>
<h3>10.3.33: nth_element()</h3>
    <a name="stl/nthelement"></a>
        <ul>
        <li > Header files: 
        <pre>

        #include&lt;algorithm&gt;
        
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>void nth_element(RandomAccessIterator first,
RandomAccessIterator nth, RandomAccessIterator last);</code>
            <li ><code>void nth_element(RandomAccessIterator first,
RandomAccessIterator nth, RandomAccessIterator last, Compare comp);</code>
        </ul>
        <li > Description:
        <ul>
            <li > The first prototype: All elements in the range <code>[first,
last)</code> are sorted relative to the element pointed to by <code>nth</code>: all elements
in the range <code>[left, nth)</code> are smaller than the element pointed to by
<code>nth</code>, and alle elements in the range <code>[nth + 1, last)</code> are greater
than the element pointed to by <code>nth</code>. The two subsets themselves are not
sorted. The <code>operator&lt;()</code> of the underlying datatype is used.
            <li > The second prototype: All elements in the range <code>[first,
last)</code> are sorted relative to the element pointed to by <code>nth</code>: all elements
in the range <code>[left, nth)</code> are smaller than the element pointed to by
<code>nth</code>, and alle elements in the range <code>[nth + 1, last)</code> are greater
than the element pointed to by <code>nth</code>. The two subsets themselves are not
sorted. The <code>comp</code> function object is used to compare the elements.
        </ul>
        <li > Example:
        <pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;functional&gt;

int main()
{
    int
        ia[] = {1, 3, 5, 7, 9, 2, 4, 6, 8, 10};

    nth_element(ia, ia + 3, ia + 10);
    copy(ia, ia + 10, ostream_iterator&lt;int&gt;(cout, " "));
    cout &lt;&lt; endl;

    nth_element(ia, ia + 5, ia + 10, greater&lt;int&gt;());
    copy(ia, ia + 10, ostream_iterator&lt;int&gt;(cout, " "));
    cout &lt;&lt; endl;

    return (0);
}
</pre>

    </ul>

<p><br><a name="l177"></a>
<h3>10.3.34: partial_sort()</h3>
    <a name="stl/partialsort"></a>
        <ul>
        <li > Header files: 
        <pre>

        #include&lt;algorithm&gt;
        
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>void partial_sort(RandomAccessIterator first,
RandomAccessIterator middle, RandomAccessIterator last);</code>
            <li ><code>void partial_sort(RandomAccessIterator first,
RandomAccessIterator middle, RandomAccessIterator last, Compare comp);</code>
        </ul>
        <li > Description:
        <ul>
            <li > The first prototype: The <code>middle - first</code> smallest elements
are sorted and stored in the <code>[first, middle)</code>, using the <code>operator&lt;()</code>
of the underlying datatype. The remaining elements of the series remain
unsorted.
            <li > The second prototype: The <code>middle - first</code> smallest
elements (according to the provided binary predicate <code>comp</code> are sorted and
stored in the <code>[first, middle)</code>. The remaining elements of the series
remain unsorted.
        </ul>
        <li > Example:
        <pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;functional&gt;

int main()
{
    int
        ia[] = {1, 3, 5, 7, 9, 2, 4, 6, 8, 10};

    partial_sort(ia, ia + 3, ia + 10);
    copy(ia, ia + 10, ostream_iterator&lt;int&gt;(cout, " "));
    cout &lt;&lt; endl;

    partial_sort(ia, ia + 5, ia + 10, greater&lt;int&gt;());
    copy(ia, ia + 10, ostream_iterator&lt;int&gt;(cout, " "));
    cout &lt;&lt; endl;

    return (0);
}
</pre>

    </ul>

<p><br><a name="l178"></a>
<h3>10.3.35: partial_sort_copy()</h3>
    <a name="stl/partialsortcopy"></a>
        <ul>
        <li > Header files: 
        <pre>

        #include&lt;algorithm&gt;
        
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>void partial_sort_copy(InputIterator first, InputIterator
last, RandomAccessIterator dest_first, RandomAccessIterator dest_last);</code>
            <li ><code>void partial_sort_copy(InputIterator first, InputIterator
last, RandomAccessIterator dest_first, RandomAccessIterator dest_last, Compare
comp);</code>
        </ul>
        <li > Description:
        <ul>
            <li > The first prototype: The smallest elements in the range
<code>[first, last)</code> are copied to the range <code>[dest_first, dest_last)</code>,
using the <code>operator&lt;()</code> of the underlying datatype. Only the number of
elements in the smaller range are copied to the second range.
            <li > The second prototype: The elements in the range
<code>[first, last)</code> are are sorted by the binary predicate <code>comp</code>. The
elements for which the predicate returns most often <code>true</code> are copied to the
range <code>[dest_first, dest_last)</code>.  Only the number of elements in the
smaller range are copied to the second range.
        </ul>
        <li > Example:
        <pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;functional&gt;

int main()
{
    int
        ia[] = {1, 10, 3, 8, 5, 6, 7, 4, 9, 2},
        ia2[6];

    partial_sort_copy(ia, ia + 10, ia2, ia2 + 6);
    copy(ia, ia + 10, ostream_iterator&lt;int&gt;(cout, " "));
    cout &lt;&lt; endl;
    copy(ia2, ia2 + 6, ostream_iterator&lt;int&gt;(cout, " "));
    cout &lt;&lt; endl;

    partial_sort_copy(ia, ia + 4, ia2, ia2 + 6);
    copy(ia2, ia2 + 6, ostream_iterator&lt;int&gt;(cout, " "));
    cout &lt;&lt; endl;

    partial_sort_copy(ia, ia + 4, ia2, ia2 + 6, greater&lt;int&gt;());
    copy(ia2, ia2 + 6, ostream_iterator&lt;int&gt;(cout, " "));
    cout &lt;&lt; endl;

    return (0);
}

</pre>

    </ul>
<p><br>
<p><br><a name="l179"></a>
<h3>10.3.36: partial_sum()</h3>
    <a name="stl/partialsum"></a>
        <ul>
        <li > Header files: 
        <pre>

        #include&lt;numeric&gt;
        
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>OutputIterator partial_sum(InputIterator first,
InputIterator last, OutputIterator result);</code>
            <li ><code>OutputIterator partial_sum(InputIterator first,
InputIterator last, OutputIterator result, BinaryOperation op);</code>
        </ul>
        <li > Description:
        <ul>
            <li > The first prototype: the value of each element in the range
<code>[result, &lt;returned OutputIterator&gt;)</code> is obtained by adding the elements
in the corresponding range of the range <code>[first, last)</code>. The first
element in the resulting range will be equal to the element pointed to by
<code>first</code>. 
            <li > The second prototype: the value of each element in the range
<code>[result, &lt;returned OutputIterator&gt;)</code> is obtained by applying the binary
operator <code>op</code> to the previous element in the resulting range and the
corresponding element in the range <code>[first, last)</code>. The first
element in the resulting range will be equal to the element pointed to by
<code>first</code>. 
        </ul>
        <li > Example:
        <pre>
#include &lt;numeric&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;functional&gt;

int main()
{
    int
        ia[] = {1, 2, 3, 4, 5},
        ia2[5];

    copy(ia2,
        partial_sum(ia, ia + 5, ia2),
        ostream_iterator&lt;int&gt;(cout, " "));
    cout &lt;&lt; endl;

    copy(ia2,
        partial_sum(ia, ia + 5, ia2, multiplies&lt;int&gt;()),
        ostream_iterator&lt;int&gt;(cout, " "));
    cout &lt;&lt; endl;

    return (0);
}
</pre>

    </ul>

<p><br><a name="l180"></a>
<h3>10.3.37: partition()</h3>
    <a name="stl/partition"></a>
        <ul>
        <li > Header files: 
        <pre>

        #include&lt;algorithm&gt;
        
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>BidirectionalIterator partition(BidirectionalIterator first,
                BidirectionalIterator last, UnaryPredicate pred);</code>
        </ul>
        <li > Description:
        <ul>
            <li > All elements in the range <code>[first, last)</code> for which the
unary predicate <code>pred</code> evaluates as <code>true</code> are placed before the elements
which evaluate as <code>false</code>. The returnvalue points just beyond the last
element in the partitioned range for which <code>pred</code> evaluates as <code>true</code>.
        </ul>
        <li > Example:
        <pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

class LessThan
{
    public:
        LessThan(int x): x(x)
        {}
        operator()(int value)
        {
            return (value &lt;= x);
        }
    private:
        int
            x;
};

int main()
{
    int
        ia[] = {1, 3, 5, 7, 9, 10, 2, 8, 6, 4},
        *split;


    split = partition(ia, ia + 10, LessThan(ia[9]));
    cout &lt;&lt; "Last element &lt;= 4 is ia[" &lt;&lt; split - ia - 1 &lt;&lt; "]\n";

    copy(ia, ia + 10, ostream_iterator&lt;int&gt;(cout, " "));
    cout &lt;&lt; endl;
    return (0);
}




</pre>

    </ul>

<p><br><a name="l181"></a>
<h3>10.3.38: prev_permutation()</h3>
    <a name="stl/prevpermutation"></a>
        <ul>
        <li > Header files: 
        <pre>

        #include&lt;algorithm&gt;
        
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>bool prev_permutation(BidirectionalIterator first,
                BidirectionalIterator last);</code>
            <li ><code>bool prev_permutation(BidirectionalIterator first,
                BidirectionalIterator last, Comp comp);</code>
        </ul>
        <li > Description:
        <ul>
            <li > The first prototype: The previous permutation given the
sequence of elements in the range <code>[first, last)</code> is determined. The
elements in the range are reordered. The value <code>true</code> is returned if a
reordering took place, the value <code>false</code> is returned if no reordering took
place, which is the case if the provided sequence was already ordered,
according to the <code>operator&lt;()</code> of the underlying data type.
            <li > The second prototype: The previous permutation given the
sequence of elements in the range <code>[first, last)</code> is determined. The
elements in the range are reordered. The value <code>true</code> is returned if a
reordering took place, the value <code>false</code> is returned if no reordering took
place, which is the case if the original sequence was already ordered,
using the binary predicate <code>comp</code> to compare two elements.
        </ul>
        <li > Example:
        <pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

class CaseString
{
    public:
        operator()(string const &amp;first, string const &amp;second) const
        {
            return (strcasecmp(first.c_str(), second.c_str()) &lt; 0);
        }
};

int main()
{
    string
        saints[] = {"Oh", "when", "the", "saints"};

    cout &lt;&lt; "All previous permutations of 'Oh when the saints':\n";

    cout &lt;&lt; "Sequences:\n";
    do
    {
        copy(saints, saints + 4, ostream_iterator&lt;string&gt;(cout, " "));
        cout &lt;&lt; endl;
    }
    while (prev_permutation(saints, saints + 4, CaseString()));


    cout &lt;&lt; "After first sorting the sequence:\n";

    sort(saints, saints + 4, CaseString());

    cout &lt;&lt; "Sequences:\n";
    while (prev_permutation(saints, saints + 4, CaseString()))
    {
        copy(saints, saints + 4, ostream_iterator&lt;string&gt;(cout, " "));
        cout &lt;&lt; endl;
    }

    cout &lt;&lt; "No (more) previous permutations\n";

    return (0);
}




</pre>

    </ul>
<p><br>
<p><br><a name="l182"></a>
<h3>10.3.39: random_shuffle()</h3>
    <a name="stl/randomshuffle"></a>
        <ul>
        <li > Header files: 
        <pre>

        #include&lt;algorithm&gt;
        
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>void random_shuffle(RandomAccessIterator first,
                                    RandomAccessIterator last);</code>
            <li ><code>void random_shuffle(RandomAccessIterator first,
                    RandomAccessIterator last, RandomNumberGenerator rand);</code>
        </ul>
        <li > Description:
        <ul>
            <li > The first prototype: The elements in the range <code>[first,
last)</code> are randomly reordered. 
            <li > The second prototype:  The elements in the range
<code>[first, last)</code> are randomly reordered, using the <code>rand</code> random number
generator, which should return an <code>int</code> in the range <code>[0, remaining)</code>,
where <code>remaining</code> is passed as argument to the <code>operator()()</code> of the
<code>rand</code> function object.
        </ul>
        <li > Example:
        <pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;time.h&gt;

class randomGenerator
{
    public:
        randomGenerator()
        { 
            srand(static_cast&lt;int&gt;(time(0)));
        }
        int operator()(int remaining) const
        {
            return (rand() % remaining);
        }
};

int main()
{
    string
        words[] = 
        { "kilo", "lima", "mike", "november", "oscar", "papa", "quebec" };
    unsigned
        size = sizeof(words) / sizeof(string);

    random_shuffle(words, words + size);

    copy(words, words + size, ostream_iterator&lt;string&gt;(cout, " "));
    cout &lt;&lt; endl;

    cout &lt;&lt; "sorting the words again\n";
    sort(words, words + size);

    randomGenerator
        rg;
    random_shuffle(words, words + size, rg);

    copy(words, words + size, ostream_iterator&lt;string&gt;(cout, " "));
    cout &lt;&lt; endl;

    return (0);
}
</pre>

    </ul>

<p><br><a name="l183"></a>
<h3>10.3.40: remove()</h3>
    <a name="stl/remove"></a>
        <ul>
        <li > Header file: 
        <pre>
#include&lt;algorithm&gt;
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>ForwardIterator remove(ForwardIterator first, 
ForwardIterator last, Type &amp;value);</code>
        </ul>
        <li > Description:
        <ul>
            <li > The elements in the range pointed to by <code>[first, last)</code>
are reordered in such a way that all values unequal to <code>value</code> are placed at
the beginning of the range. The returned forward iterator points to the first
element, after reordering, that can be removed. The range <code>[returnvalue,
last)</code> is called the <em>leftover</em> of the algorithm. The leftover may contain
other values than <code>value</code>, but these can also safely be removed, as they are
also present in the range <code>[first, returnvalue)</code>. 
        </ul>
        <li > Example:
        <pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

int main()
{
    string
        words[] = 
        { "kilo", "alpha", "lima", "mike", "alpha", "november", "alpha", 
            "oscar", "alpha", "alpha", "papa", "quebec" },
        *removed;
    unsigned
        size = sizeof(words) / sizeof(string);

    cout &lt;&lt; "Removing all \"alpha\"s:\n";
    removed = remove(words, words + size, "alpha");
    copy(words, removed, ostream_iterator&lt;string&gt;(cout, " "));
    cout &lt;&lt; endl
         &lt;&lt; "Trailing elements are:\n";
    copy(removed, words + size, ostream_iterator&lt;string&gt;(cout, " "));
    cout &lt;&lt; endl;

    return (0);
}
</pre>

    </ul>

<p><br><a name="l184"></a>
<h3>10.3.41: remove_copy()</h3>
    <a name="stl/removecopy"></a>
        <ul>
        <li > Header file: 
        <pre>
#include&lt;algorithm&gt;
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>OutputIterator remove_copy(InputIterator first, 
InputIterator last, OutputIterator result, Type &amp;value);</code>
        </ul>
        <li > Description:
        <ul>
            <li > The elements in the range pointed to by <code>[first, last)</code>
not matching <code>value</code> are copied to the range <code>[result, returnvalue)</code>,
where <code>returnvalue</code> is the value returned by the function. The range
<code>[first, last)</code> is not modified.
        </ul>
        <li > Example:
        <pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;functional&gt;

class EqualAlpha
{
    public:
        operator()(string const &amp;word) const    
        {
            return (word == "alpha");
        }
};

int main()
{
    string
        words[] = 
        { "kilo", "alpha", "lima", "mike", "alpha", "november", "alpha", 
            "oscar", "alpha", "alpha", "papa", "quebec" };
    unsigned
        size = sizeof(words) / sizeof(string);
    string
        remaining[size - count_if(words, words + size, EqualAlpha())],
        *returnvalue;

    returnvalue = remove_copy(words, words + size, remaining, "alpha");
                                                
    cout &lt;&lt; "Removing all \"alpha\"s:\n";
    copy(remaining, returnvalue, ostream_iterator&lt;string&gt;(cout, " "));
    cout &lt;&lt; endl;

    return (0);
}
</pre>

    </ul>

<p><br><a name="l185"></a>
<h3>10.3.42: remove_if()</h3>
    <a name="stl/removeif"></a>
        <ul>
        <li > Header file: 
        <pre>
#include&lt;algorithm&gt;
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>ForwardIterator remove_if(ForwardIterator first, 
ForwardIterator last, UnaryPredicate pred);</code>
        </ul>
        <li > Description:
        <ul>
            <li > The elements in the range pointed to by <code>[first, last)</code>
are reordered in such a way that all values for which the unary predicate
<code>pred</code> evaluates as <code>false</code> are placed at the beginning of the range. The
returned forward iterator points to the first element, after reordering, for
which <code>pred</code> returns <code>true</code>. The range <code>[returnvalue, last)</code> is
called the <em>leftover</em> of the algorithm. The leftover may contain other
values than <code>value</code>, but these can also safely be removed, as they are also
present in the range <code>[first, returnvalue)</code>.
        </ul> 
        <code></code> Example:<pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

class Remover
{
    public:
        bool operator()(string const &amp;str)
        {
            return (str == "alpha");
        }
};

int main()
{
    string
        words[] = 
        { "kilo", "alpha", "lima", "mike", "alpha", "november", "alpha", 
            "oscar", "alpha", "alpha", "papa", "quebec" },
        *removed;
    unsigned
        size = sizeof(words) / sizeof(string);

    cout &lt;&lt; "Removing all \"alpha\"s:\n";
    removed = remove_if(words, words + size, Remover());
    copy(words, removed, ostream_iterator&lt;string&gt;(cout, " "));
    cout &lt;&lt; endl
         &lt;&lt; "Trailing elements are:\n";
    copy(removed, words + size, ostream_iterator&lt;string&gt;(cout, " "));
    cout &lt;&lt; endl;

    return (0);
}
</pre>
 
    </ul>

<p><br><a name="l186"></a>
<h3>10.3.43: remove_copy_if()</h3>
    <a name="stl/removecopyif"></a>
        <ul>
        <li > Header file: 
        <pre>
#include&lt;algorithm&gt;
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>OutputIterator remove_copy_if(InputIterator first, 
InputIterator last, OutputIterator result, UnaryPredicate pred);</code>
        </ul>
        <li > Description:
        <ul>
            <li > The elements in the range pointed to by <code>[first, last)</code>
for which the unary predicate <code>pred</code> returns <code>true</code> are copied to the
range <code>[result, returnvalue)</code>, where <code>returnvalue</code> is the value
returned by the function. The range <code>[first, last)</code> is not modified.
        </ul>
        <li > Example:
        <pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;functional&gt;

class EqualAlpha
{
    public:
        operator()(string const &amp;word) const    
        {
            return (word == "alpha");
        }
};

class Remover
{
    public:
        bool operator()(string const &amp;str) const
        {
            return (str == "alpha");
        }
};


int main()
{
    string
        words[] = 
        { "kilo", "alpha", "lima", "mike", "alpha", "november", "alpha", 
            "oscar", "alpha", "alpha", "papa", "quebec" };
    unsigned
        size = sizeof(words) / sizeof(string);
    string
        remaining[size - count_if(words, words + size, EqualAlpha())],
        *returnvalue;

    returnvalue = remove_copy_if(words, words + size, remaining, Remover());
                                                
    cout &lt;&lt; "Removing all \"alpha\"s:\n";
    copy(remaining, returnvalue, ostream_iterator&lt;string&gt;(cout, " "));
    cout &lt;&lt; endl;

    return (0);
}
</pre>

    </ul>

<p><br><a name="l187"></a>
<h3>10.3.44: replace()</h3>
    <a name="stl/replace"></a>
        <ul>
        <li > Header file: 
        <pre>
#include&lt;algorithm&gt;
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>ForwardIterator replace(ForwardIterator first, 
ForwardIterator last, Type &amp;oldvalue, Type &amp;newvalue);</code>
        </ul>
        <li > Description:
        <ul>
            <li > All elements equal to <code>oldvalue</code> in the range pointed to by
<code>[first, last)</code> are replaced by the value <code>newvalue</code>. 
        </ul>
        <li > Example:
        <pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

int main()
{
    string
        words[] = 
        { "kilo", "alpha", "lima", "mike", "alpha", "november", "alpha", 
            "oscar", "alpha", "alpha", "papa", "quebec" },
        *removed;
    unsigned
        size = sizeof(words) / sizeof(string);

    replace(words, words + size, string("alpha"), string("ALPHA"));
    copy(words, words + size, ostream_iterator&lt;string&gt;(cout, " "));
    cout &lt;&lt; endl;

    return (0);
}
</pre>

    </ul>

<p><br><a name="l188"></a>
<h3>10.3.45: replace_copy()</h3>
    <a name="stl/replacecopy"></a>
        <ul>
        <li > Header file: 
        <pre>
#include&lt;algorithm&gt;
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>OutputIterator replace_copy(InputIterator first, 
InputIterator last, OutputIterator result, Type &amp;oldvalue, Type &amp;newvalue);</code>
        </ul>
        <li > Description:
        <ul>
            <li > All elements equal to <code>oldvalue</code> in the range pointed to by
<code>[first, last)</code> are replaced by the value <code>newvalue</code> in a new range
<code>[result, returnvalue)</code>, where <code>returnvalue</code> is the returnvalue of the
function.  
        </ul>
        <li > Example:
        <pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;functional&gt;
int main()
{
    string
        words[] = 
        { "kilo", "alpha", "lima", "mike", "alpha", "november", "alpha", 
            "oscar", "alpha", "alpha", "papa", "quebec" };
    unsigned
        size = sizeof(words) / sizeof(string);
    string
        remaining[size],
        *returnvalue;

    returnvalue = replace_copy(words, words + size, remaining,
                                string("alpha"), string("ALPHA")); 
                                                
    copy(remaining, returnvalue, ostream_iterator&lt;string&gt;(cout, " "));
    cout &lt;&lt; endl;

    return (0);
}
</pre>

    </ul>

<p><br><a name="l189"></a>
<h3>10.3.46: replace_if()</h3>
    <a name="stl/replaceif"></a>
        <ul>
        <li > Header file: 
        <pre>
#include&lt;algorithm&gt;
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>ForwardIterator replace_if(ForwardIterator first, 
ForwardIterator last, UnaryPredicate pred, Type const &amp;value);</code>
        </ul>
        <li > Description:
        <ul>
            <li > The elements in the range pointed to by <code>[first, last)</code>
for which the unary predicate <code>pred</code> evaluates as <code>true</code> 
are replaced by <code>newvalue</code>.
        </ul> 
        <code></code> Example:<pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

class Replacer
{
    public:
        bool operator()(string const &amp;str)
        {
            return (str == "alpha");
        }
};

int main()
{
    string
        words[] = 
        { "kilo", "alpha", "lima", "mike", "alpha", "november", "alpha", 
            "oscar", "alpha", "alpha", "papa", "quebec" };
    unsigned
        size = sizeof(words) / sizeof(string);

    replace_if(words, words + size, Replacer(), string("ALPHA"));
    copy(words, words + size, ostream_iterator&lt;string&gt;(cout, " "));
    cout &lt;&lt; endl;

    return (0);
}
</pre>
 
    </ul>

<p><br><a name="l190"></a>
<h3>10.3.47: replace_copy_if()</h3>
    <a name="stl/replacecopyif"></a>
        <ul>
        <li > Header file: 
        <pre>
#include&lt;algorithm&gt;
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>OutputIterator replace_copy_if(ForwardIterator first, 
ForwardIterator last, OutputIterator result, UnaryPredicate pred, Type const
&amp;value);</code>  
        </ul>
        <li > Description:
        <ul>
            <li > The elements in the range pointed to by <code>[first, last)</code>
are copied to the range <code>[result, returnvalue)</code>, where <code>returnvalue</code> is
the value returned by the function. The elements for which the unary predicate
<code>pred</code> returns <code>true</code> are replaced by <code>newvalue</code>. The range
<code>[first, last)</code> is not modified.
        </ul>
        <li > Example:
        <pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;functional&gt;

class Replacer
{
    public:
        bool operator()(string const &amp;str) const
        {
            return (str == "alpha");
        }
};


int main()
{
    string
        words[] = 
        { "kilo", "alpha", "lima", "mike", "alpha", "november", "alpha", 
            "oscar", "alpha", "alpha", "papa", "quebec" };
    unsigned
        size = sizeof(words) / sizeof(string);
    string
        result[size];
                                                
    replace_copy_if(words, words + size, result, Replacer(), string("ALPHA"));
    copy (result, result + size, ostream_iterator&lt;string&gt;(cout, " "));
    cout &lt;&lt; endl;

    return (0);
}
</pre>

    </ul>

<p><br><a name="l191"></a>
<h3>10.3.48: reverse()</h3>
    <a name="stl/reverse"></a>
        <ul>
        <li > Header files: 
        <pre>

        #include&lt;algorithm&gt;
        
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>void reverse(BidirectionalIterator first,
                BidirectionalIterator last);</code>
        </ul>
        <li > Description:
        <ul>
            <li > The elements in the range pointed to by <code>[first, last)</code>
are reversed.
        </ul>
        <li > Example:
        <pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

int main()
{
    string
        line;

    while (getline(cin, line))
    {
        reverse(line.begin(), line.end());
        cout &lt;&lt; line &lt;&lt; endl;
    }

    return (0);
}
</pre>

    </ul>

<p><br><a name="l192"></a>
<h3>10.3.49: reverse_copy()</h3>
    <a name="stl/reversecopy"></a>
        <ul>
        <li > Header files: 
        <pre>

        #include&lt;algorithm&gt;
        
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>OutputIterator reverse_copy(BidirectionalIterator first,
                BidirectionalIterator last, OutputIterator result);</code>
        </ul>
        <li > Description:
        <ul>
            <li > The elements in the range pointed to by <code>[first, last)</code>
are copied to the range <code>[result, returnvalue)</code> in reversed order. The
value <code>returnvalue</code> is the value that is returned by the function. 
        </ul>
        <li > Example:
        <pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

int main()
{
    string
        line;

    while (getline(cin, line))
    {
        unsigned
            size = line.size();
        char
            copy[size + 1];

        cout &lt;&lt; "line: " &lt;&lt; line &lt;&lt; endl &lt;&lt;
                "reversed: ";
        reverse_copy(line.begin(), line.end(), copy);
        copy[size] = 0;     // 0 is not part of the reversed
                            // line !
        cout &lt;&lt; copy &lt;&lt; endl;
    }

    return (0);
}
</pre>

    </ul>

<p><br><a name="l193"></a>
<h3>10.3.50: rotate()</h3>
    <a name="stl/rotate"></a>
        <ul>
        <li > Header files: 
        <pre>

        #include&lt;algorithm&gt;
        
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>void rotate(ForwardIterator first, ForwardIterator middle,
ForwardIterator last);</code>
        </ul>
        <li > Description:
        <ul>
            <li > The elements implied by the range <code>[first, middle)</code> are
moved to the end of the container, the elements implied by the range
<code>[middle, last)</code> are moved to the beginning of the container.
        </ul>
        <li > Example:
        <pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

int main()
{
    string
        words[] =
        { "kilo", "lima", "mike", "november", "oscar", "papa", "quebec", 
          "echo", "foxtrot", "golf", "hotel", "india", "juliet" };
    unsigned const
        size = sizeof(words) / sizeof(string),
        midsize = 7;

    rotate(words, words + midsize, words + size);

    copy(words, words + size, ostream_iterator&lt;string&gt;(cout, " "));
    cout &lt;&lt; endl;

    return (0);
}
</pre>

    </ul>

<p><br><a name="l194"></a>
<h3>10.3.51: rotate_copy()</h3>                     
    <a name="stl/rotatecopy"></a>
        <ul>
        <li > Header files: 
        <pre>

        #include&lt;algorithm&gt;
        
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>OutputIterator rotate_copy(ForwardIterator first,
ForwardIterator middle, ForwardIterator last, OutputIterator result);</code>
        </ul>
        <li > Description:
        <ul>
            <li > The elements implied by the range <code>[middle, last)</code> and
then the elements implied by the range <code>[first, middle)</code> are copied to the
destination container having range <code>[result, returnvalue)</code>, where
<code>returnvalue</code> is the iterator returned by the function.
        </ul>
        <li > Example:
        <pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

int main()
{
    string
        words[] =
        { "kilo", "lima", "mike", "november", "oscar", "papa", "quebec", 
          "echo", "foxtrot", "golf", "hotel", "india", "juliet" };
    unsigned const
        size = sizeof(words) / sizeof(string),
        midsize = 7;
    string
        out[size];

    

    copy(out,
        rotate_copy(words, words + midsize, words + size, out),
        ostream_iterator&lt;string&gt;(cout, " "));
    cout &lt;&lt; endl;

    return (0);
}
</pre>

    </ul>

<p><br><a name="l195"></a>
<h3>10.3.52: search()</h3>
    <a name="stl/search"></a>
        <ul>
        <li > Header files: 
        <pre>

        #include&lt;algorithm&gt;
        
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>ForwardIterator1 search(ForwardIterator1 first1,
ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2);</code>
            <li ><code>ForwardIterator1 search(ForwardIterator1 first1,
ForwardIterator1 last1, ForwardIterator2 first2, ForwardIterator2 last2,
BinaryPredicate pred);</code>
        </ul>
        <li > Description:
        <ul>
            <li > The first prototype: An iterator into the first range
<code>[first1, last1)</code> is returned where the elements in the range
<code>[first2, last2)</code> are found, using the <code>operator==()</code> operator of the
underlying data type. If no such location exists, <code>last1</code> is returned.
            <li > The second prototype: An iterator into the first range
<code>[first1, last1)</code> is returned where the elements in the range
<code>[first2, last2)</code> are found, using the provided binary predicate <code>pred</code>
to compare the elements in the two ranges. If no such location exists,
<code>last1</code> is returned.
        </ul>
        <li > Example:
        <pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;


class absInt
{
    public:
        operator()(int i1, int i2)
        {
            return (abs(i1) == abs(i2));
        }
};

int main()
{
    int
        range1[] = 
            {-2, -4, -6, -8, 2, 4, 6, 8},
        range2[] = 
            {6, 8};

    copy
    (
        search(range1, range1 + 8, range2, range2 + 2),
        range1 + 8,
        ostream_iterator&lt;int&gt;(cout, " ")
    );
    cout &lt;&lt; endl;

    copy
    (
        search(range1, range1 + 8, range2, range2 + 2, absInt()),
        range1 + 8,
        ostream_iterator&lt;int&gt;(cout, " ")
    );
    cout &lt;&lt; endl;

    
    return (0);
}
</pre>

    </ul>
<p><br>
<p><br><a name="l196"></a>
<h3>10.3.53: search_n()</h3>
    <a name="stl/searchn"></a>
        <ul>
        <li > Header files: 
        <pre>

        #include&lt;algorithm&gt;
        
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>ForwardIterator1 search_n(ForwardIterator1 first1,
ForwardIterator1 last1, Size count, Type const &amp; value);</code>
            <li ><code>ForwardIterator1 search_n(ForwardIterator1 first1,
ForwardIterator1 last1, Size count, Type const &amp; value, BinaryPredicate
pred);</code>
        </ul>
        <li > Description:
        <ul>
            <li > The first prototype: An iterator into the first range
<code>[first1, last1)</code> is returned where <code>n</code> elements having value <code>value</code>
are found, using the <code>operator==()</code> operator of the underlying data type to
compare the elements. If no such location exists, <code>last1</code> is returned.
            <li > The second prototype: An iterator into the first range
<code>[first1, last1)</code> is returned where <code>n</code> elements having value <code>value</code>
are found, using the provided binary predicate <code>pred</code> to compare the
elements. If no such location exists, <code>last1</code> is returned.
        </ul>
        <li > Example:
        <pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;

class absInt
{
    public:
        operator()(int i1, int i2)
        {
            return (abs(i1) == abs(i2));
        }
};

int main()
{
    int
        range1[] = 
            {-2, -4, -4, -6, -8, 2, 4, 4, 6, 8},
        range2[] = 
            {6, 8};

    copy
    (
        search_n(range1, range1 + 8, 2, 4),
        range1 + 8,
        ostream_iterator&lt;int&gt;(cout, " ")
    );
    cout &lt;&lt; endl;

    copy
    (
        search_n(range1, range1 + 8, 2, 4, absInt()),
        range1 + 8,
        ostream_iterator&lt;int&gt;(cout, " ")
    );
    cout &lt;&lt; endl;

    
    return (0);
}
</pre>

    </ul>
<p><br>
<p><br><a name="l197"></a>
<h3>10.3.54: set_difference()</h3>
    <a name="stl/setdifference"></a>
        <ul>
        <li > Header files: 
        <pre>

        #include&lt;algorithm&gt;
        
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>OutputIterator set_difference(
                InputIterator1 first1, InputIterator1 last1,
                InputIterator2 first2, InputIterator2 last2,
                OutputIterator result);</code>
            <li ><code>OutputIterator set_difference(
                InputIterator1 first1, InputIterator1 last1,
                InputIterator2 first2, InputIterator2 last2,
                OutputIterator result, Compare comp);</code>
        </ul>
        <li > Description:
        <ul>
            <li > The first prototype: a sorted sequence of the elements
pointed to by the range <code>[first1, last1)</code> that are not present in the
range <code>[first2, last2)</code> is returned, starting at <code>[result)</code>, and
ending at the outputiterator that is returned by the function. The elements in
the two ranges must have been sorted using the <code>operator&lt;()</code> of the
underlying datatype.
            <li > The second prototype: a sorted sequence of the elements
pointed to by the range <code>[first1, last1)</code> that are not present in the
range <code>[first2, last2)</code> is returned, starting at <code>[result)</code>, and
ending at the outputiterator that is returned by the function. The elements in
the two ranges must have been sorted using the <code>comp</code> function object.
        </ul>
        <li > Example:
        <pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

class CaseLess
{
    public:
        operator()(string const &amp;left, string const &amp;right)
        {
            return (strcasecmp(left.c_str(), right.c_str()) &lt; 0);
        }
};

int main()
{
    string
        set1[] = 
        { "kilo", "lima", "mike", "november", 
            "oscar", "papa", "quebec" },
        set2[] =
        { "papa", "quebec", "romeo"},
        result[7],
        *returned;

    copy(result, 
        set_difference(set1, set1 + 7, set2, set2 + 3, result),
        ostream_iterator&lt;string&gt;(cout, " "));
    cout &lt;&lt; endl;

    string
        set3[] =
        { "PAPA", "QUEBEC", "ROMEO"};
    copy(result, 
        set_difference(set1, set1 + 7, set3, set3 + 3, result,
        CaseLess()),
        ostream_iterator&lt;string&gt;(cout, " "));
    cout &lt;&lt; endl;

    return (0);
}
</pre>

    </ul>

<p><br><a name="l198"></a>
<h3>10.3.55: set_intersection()</h3>
    <a name="stl/setintersection"></a>
        <ul>
        <li > Header files: 
        <pre>

        #include&lt;algorithm&gt;
        
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>OutputIterator set_intersection(
                InputIterator1 first1, InputIterator1 last1,
                InputIterator2 first2, InputIterator2 last2,
                OutputIterator result);</code>
            <li ><code>OutputIterator set_intersection(
                InputIterator1 first1, InputIterator1 last1,
                InputIterator2 first2, InputIterator2 last2,
                OutputIterator result, Compare comp);</code>
        </ul>
        <li > Description:
        <ul>
            <li > The first prototype: a sorted sequence of the elements
pointed to by the range <code>[first1, last1)</code> that are also present in the
ranges <code>[first2, last2)</code> is returned, starting at <code>[result)</code>, and
ending at the outputiterator that is returned by the function. The elements in
the two ranges must have been sorted using the <code>operator&lt;()</code> of the
underlying datatype.
            <li > The second prototype: a sorted sequence of the elements
pointed to by the range <code>[first1, last1)</code> that are also present in the
ranges <code>[first2, last2)</code> is returned, starting at <code>[result)</code>, and
ending at the outputiterator that is returned by the function. The elements in
the two ranges must have been sorted using the <code>comp</code> function object.
        </ul>
        <li > Example:
        <pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

class CaseLess
{
    public:
        operator()(string const &amp;left, string const &amp;right)
        {
            return (strcasecmp(left.c_str(), right.c_str()) &lt; 0);
        }
};

int main()
{
    string
        set1[] = 
        { "kilo", "lima", "mike", "november", 
            "oscar", "papa", "quebec" },
        set2[] =
        { "papa", "quebec", "romeo"},
        result[7],
        *returned;

    copy(result, 
        set_intersection(set1, set1 + 7, set2, set2 + 3, result),
        ostream_iterator&lt;string&gt;(cout, " "));
    cout &lt;&lt; endl;

    string
        set3[] =
        { "PAPA", "QUEBEC", "ROMEO"};
    copy(result, 
        set_intersection(set1, set1 + 7, set3, set3 + 3, result,
        CaseLess()),
        ostream_iterator&lt;string&gt;(cout, " "));
    cout &lt;&lt; endl;

    return (0);
}
</pre>

    </ul>

<p><br><a name="l199"></a>
<h3>10.3.56: set_symmetric_difference()</h3>        
    <a name="stl/setsymmetricdifference"></a>
        <ul>
        <li > Header files: 
        <pre>

        #include&lt;algorithm&gt;
        
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>OutputIterator set_symmetric_difference(
                InputIterator1 first1, InputIterator1 last1,
                InputIterator2 first2, InputIterator2 last2,
                OutputIterator result);</code>
            <li ><code>OutputIterator set_symmetric_difference(
                InputIterator1 first1, InputIterator1 last1,
                InputIterator2 first2, InputIterator2 last2,
                OutputIterator result, Compare comp);</code>
        </ul>
        <li > Description:
        <ul>
            <li > The first prototype: a sorted sequence of the elements
pointed to by the range <code>[first1, last1)</code> that are not present in the
range <code>[first2, last2)</code> and those in the range <code>[first2, last2)</code>
that are not present in the range <code>[first1, last1)</code> is returned, 
starting
at <code>[result)</code> and ending at the outputiterator that is returned by the
function. The elements in the two ranges must have been sorted using the
<code>operator&lt;()</code> of the underlying datatype.
            <li > The second prototype: a sorted sequence of the elements a
sorted sequence of the elements pointed to by the range <code>[first1, last1)</code>
that are not present in the range <code>[first2, last2)</code> and those in the
range <code>[first2, last2)</code> that are not present in the range <code>[first1,
last1)</code> is returned, starting at <code>[result)</code> and ending at the
outputiterator that is returned by the function. The elements in the two
ranges must have been sorted using the <code>comp</code> function object.
        </ul>
        <li > Example:
        <pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

class CaseLess
{
    public:
        operator()(string const &amp;left, string const &amp;right)
        {
            return (strcasecmp(left.c_str(), right.c_str()) &lt; 0);
        }
};

int main()
{
    string
        set1[] = 
        { "kilo", "lima", "mike", "november", 
            "oscar", "papa", "quebec" },
        set2[] =
        { "papa", "quebec", "romeo"},
        result[7],
        *returned;

    copy(result, 
        set_symmetric_difference(set1, set1 + 7, set2, set2 + 3, result),
        ostream_iterator&lt;string&gt;(cout, " "));
    cout &lt;&lt; endl;

    string
        set3[] =
        { "PAPA", "QUEBEC", "ROMEO"};
    copy(result, 
        set_symmetric_difference(set1, set1 + 7, set3, set3 + 3, result,
        CaseLess()),
        ostream_iterator&lt;string&gt;(cout, " "));
    cout &lt;&lt; endl;

    return (0);
}
</pre>

    </ul>
<p><br>
<p><br><a name="l200"></a>
<h3>10.3.57: set_union()</h3>
    <a name="stl/setunion"></a>
        <ul>
        <li > Header files: 
        <pre>

        #include&lt;algorithm&gt;
        
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>OutputIterator set_intersection(
                InputIterator1 first1, InputIterator1 last1,
                InputIterator2 first2, InputIterator2 last2,
                OutputIterator result);</code>
            <li ><code>OutputIterator set_intersection(
                InputIterator1 first1, InputIterator1 last1,
                InputIterator2 first2, InputIterator2 last2,
                OutputIterator result, Compare comp);</code>
        </ul>
        <li > Description:
        <ul>
            <li > The first prototype: a sorted sequence of the elements
pointed to by the range <code>[first1, last1)</code> that are also present in the
ranges <code>[first2, last2)</code> is returned, starting at <code>[result)</code>, and
ending at the outputiterator that is returned by the function. The elements in
the two ranges must have been sorted using the <code>operator&lt;()</code> of the
underlying datatype.
            <li > The second prototype: a sorted sequence of the elements
pointed to by the range <code>[first1, last1)</code> that are also present in the
ranges <code>[first2, last2)</code> is returned, starting at <code>[result)</code>, and
ending at the outputiterator that is returned by the function. The elements in
the two ranges must have been sorted using the <code>comp</code> function object.
        </ul>
        <li > Example:
        <pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

class CaseLess
{
    public:
        operator()(string const &amp;left, string const &amp;right)
        {
            return (strcasecmp(left.c_str(), right.c_str()) &lt; 0);
        }
};

int main()
{
    string
        set1[] = 
        { "kilo", "lima", "mike", "november", 
            "oscar", "papa", "quebec" },
        set2[] =
        { "papa", "quebec", "romeo"},
        result[7],
        *returned;

    copy(result, 
        set_intersection(set1, set1 + 7, set2, set2 + 3, result),
        ostream_iterator&lt;string&gt;(cout, " "));
    cout &lt;&lt; endl;

    string
        set3[] =
        { "PAPA", "QUEBEC", "ROMEO"};
    copy(result, 
        set_intersection(set1, set1 + 7, set3, set3 + 3, result,
        CaseLess()),
        ostream_iterator&lt;string&gt;(cout, " "));
    cout &lt;&lt; endl;

    return (0);
}
</pre>

    </ul>

<p><br><a name="l201"></a>
<h3>10.3.58: sort()</h3>
    <a name="stl/sort"></a>
        <ul>
        <li > Header files: 
        <pre>

        #include&lt;algorithm&gt;
        
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>void sort(
                RandomAccessIterator first, RandomAccessIterator last);</code>
            <li ><code>void sort(
                RandomAccessIterator first, RandomAccessIterator last,
                Compare comp);</code>
        </ul>
        <li > Description:
        <ul>
           <li > The first prototype: the elements in the range <code>[first,
last)</code> are sorted in ascending order, using the <code>operator&lt;()</code> of the
underlying datatype.
            <li > The second prototype: the elements in the range
<code>[first, last)</code> are sorted in ascending order, using the <code>comp</code>
function object to compare the elements.
        </ul>
        <li > Example:
        <pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;functional&gt;

int main()
{
    string
        words[] = 
        {"november", "kilo", "mike", "lima", 
            "oscar", "quebec", "papa"};

    sort(words, words + 7);
    copy(words, words + 7,
        ostream_iterator&lt;string&gt;(cout, " "));
    cout &lt;&lt; endl;

    sort(words, words + 7, greater&lt;string&gt;());
    copy(words, words + 7,
        ostream_iterator&lt;string&gt;(cout, " "));
    cout &lt;&lt; endl;

    return (0);
}
</pre>

    </ul>

<p><br><a name="l202"></a>
<h3>10.3.59: stable_partition()</h3>
    <a name="stl/stablepartition"></a>
        <ul>
        <li > Header files: 
        <pre>

        #include&lt;algorithm&gt;
        
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>BidirectionalIterator stable_partition(BidirectionalIterator
                first,
                BidirectionalIterator last, UnaryPredicate pred);</code>
        </ul>
        <li > Description:
        <ul>
            <li > All elements in the range <code>[first, last)</code> for which the
unary predicate <code>pred</code> evaluates as <code>true</code> are placed before the elements
which evaluate as <code>false</code>. The relative order of the elements in the
container is kept. The returnvalue points just beyond the last element in the
partitioned range for which <code>pred</code> evaluates as <code>true</code>.
        </ul>
        <li > Example:
        <pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

class LessThan
{
    public:
        LessThan(int x): x(x)
        {}
        operator()(int value)
        {
            return (value &lt;= x);
        }
    private:
        int
            x;
};

int main()
{
    int
        org[] = {1, 3, 5, 7, 9, 10, 2, 8, 6, 4},
        ia[10],
        *split;


    copy(org, org + 10, ia);
    split = partition(ia, ia + 10, LessThan(ia[9]));
    cout &lt;&lt; "Last element &lt;= 4 is ia[" &lt;&lt; split - ia - 1 &lt;&lt; "]\n";

    copy(ia, ia + 10, ostream_iterator&lt;int&gt;(cout, " "));
    cout &lt;&lt; endl;

    copy(org, org + 10, ia);
    split = stable_partition(ia, ia + 10, LessThan(ia[9]));
    cout &lt;&lt; "Last element &lt;= 4 is ia[" &lt;&lt; split - ia - 1 &lt;&lt; "]\n";

    copy(ia, ia + 10, ostream_iterator&lt;int&gt;(cout, " "));
    cout &lt;&lt; endl;
    return (0);
}




</pre>

    </ul>

<p><br><a name="l203"></a>
<h3>10.3.60: stable_sort()</h3>
    <a name="stl/stablesort"></a>
        <ul>
        <li > Header files: 
        <pre>

        #include&lt;algorithm&gt;
        
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>void stable_sort(
                RandomAccessIterator first, RandomAccessIterator last);</code>
            <li ><code>void stable_sort(
                RandomAccessIterator first, RandomAccessIterator last,
                Compare comp);</code>
        </ul>
        <li > Description:
        <ul>
           <li > The first prototype: the elements in the range <code>[first,
last)</code> are stable_sorted in ascending order, using the <code>operator&lt;()</code> of the
underlying datatype. The relative order of the equal elements is kept.
            <li > The second prototype: the elements in the range
<code>[first, last)</code> are stable_sorted in ascending order, using the <code>comp</code>
function object to compare the elements. The relative order of the equal
elements is kept.
        </ul>
        <li > Example:
        <pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;functional&gt;

class CmpFirst
{
    public:
        operator()(string const &amp;left, string const &amp;right)
        {
            return (left[0] &lt; right[0]);
        }
};

int main()
{
    string
        words[] = 
        {"piper", "november", "kilo", "mooney", "mike", "lima", 
            "oscar", "quebec", "papa", "netherlands"};

    stable_sort(words, words + 10, CmpFirst());
    copy(words, words + 10,
        ostream_iterator&lt;string&gt;(cout, " "));
    cout &lt;&lt; endl;

    return (0);
}

</pre>

    </ul>
             
<p><br><a name="l204"></a>
<h3>10.3.61: swap()</h3>                   
    <a name="stl/swap"></a>
        <ul>
        <li > Header file: 
        <pre>
#include&lt;algorithm&gt;
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>void swap(Type &amp;object1, Type &amp;object2);</code>
        </ul>
        <li > Description:
        <ul>
            <li > The elements <code>object1</code> and <code>object2</code> change values.
        </ul>
        <li > Example:
        <pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

int main()
{
    string
        first[] = {"alpha", "bravo", "charley", "delta", "echo", "delta"},
        second[] = {"echo", "foxtrot", "golf", "hotel", "india", "kilo"};
    unsigned
        n = sizeof(first) / sizeof(string);
    
    cout &lt;&lt; "Before:\n";
    copy(first, first + n, ostream_iterator&lt;string&gt;(cout, " "));
    cout &lt;&lt; endl;
    copy(second, second + n, ostream_iterator&lt;string&gt;(cout, " "));
    cout &lt;&lt; endl;

    for (unsigned idx = 0; idx &lt; n; ++idx)
        swap(first[idx], second[idx]);

    cout &lt;&lt; "After:\n";
    copy(first, first + n, ostream_iterator&lt;string&gt;(cout, " "));
    cout &lt;&lt; endl;
    copy(second, second + n, ostream_iterator&lt;string&gt;(cout, " "));
    cout &lt;&lt; endl;

    return (0);
}
</pre>

    </ul>

<p><br><a name="l205"></a>
<h3>10.3.62: swap_ranges()</h3>
    <a name="stl/swapranges"></a>
        <ul>
        <li > Header file: 
        <pre>
#include&lt;algorithm&gt;
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>ForwardIterator2 swap_ranges(ForwardIterator1 first1, 
                ForwardIterator1 last1, ForwardIterator2 result);</code>
        </ul>
        <li > Description:
        <ul>
            <li > The elements in the ranges 
pointed to by <code>[first1, last1)</code> are swapped with the elements in the
ranges <code>[result, returnvalue)</code>, where <code>returnvalue</code> is the value
returned by the function. The two ranges must be disjoint.
        </ul>
        <li > Example:
        <pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

int main()
{
    string
        first[] = {"alpha", "bravo", "charley", "delta", "echo", "delta"},
        second[] = {"echo", "foxtrot", "golf", "hotel", "india", "kilo"};
    unsigned
        n = sizeof(first) / sizeof(string);
    
    cout &lt;&lt; "Before:\n";
    copy(first, first + n, ostream_iterator&lt;string&gt;(cout, " "));
    cout &lt;&lt; endl;
    copy(second, second + n, ostream_iterator&lt;string&gt;(cout, " "));
    cout &lt;&lt; endl;

    swap_ranges(first, first + n, second);

    cout &lt;&lt; "After:\n";
    copy(first, first + n, ostream_iterator&lt;string&gt;(cout, " "));
    cout &lt;&lt; endl;
    copy(second, second + n, ostream_iterator&lt;string&gt;(cout, " "));
    cout &lt;&lt; endl;

    return (0);
}
</pre>

    </ul>

<p><br>
    <a name="TRANSFORM"></a><a name="l206"></a>
<h3>10.3.63: transform()</h3>
    <a name="stl/transform"></a>
        <ul>
        <li > Header files: 
        <pre>

        #include&lt;algorithm&gt;
        
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>OutputIterator transform(InputIterator first, InputIterator
last, OutputIterator result, UnaryOperator op);</code>
            <li ><code>OutputIterator transform(InputIterator1 first1, InputIterator1
last1, InputIterator2 first2, OutputIterator result, BinaryOperator op);</code>
        </ul>
        <li > Description:
        <ul>
            <li > The first prototype: the unary operator <code>op</code> is applied to
each of the elements in the range <code>[first, last)</code>, and the resulting
values are stored in the range starting at <code>result</code>. The returnvalue points
just beyond the last generated element.
            <li > The second prototype: the binary operator <code>op</code> is applied to
each of the elements in the range <code>[first, last)</code> and the corresponding
element in the second range starting at <code>first2</code>. The resulting
values are stored in the range starting at <code>result</code>. The returnvalue points
just beyond the last generated element.
        </ul>
        <li > Example:
        <pre>
#include &lt;functional&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;ctype.h&gt;

class Caps
{
    public:
        string operator()(string const &amp;src)
        {
            string
                tmp = src;

            transform(&amp;tmp[0], &amp;tmp[tmp.size()], &amp;tmp[0], toupper);
            return (tmp);
        }
};

int main()
{
    string
        words[] = {"alpha", "bravo", "charley"};

    copy(words, transform(words, words + 3, words, Caps()),
            ostream_iterator&lt;string&gt;(cout, " "));
    cout &lt;&lt; endl;

    int
        values[] = {1, 2, 3, 4, 5};
    vector&lt;int&gt;
        squares;

    transform(values, values + 5, values, 
                back_inserter(squares), multiplies&lt;int&gt;());

    copy(squares.begin(), squares.end(), 
            ostream_iterator&lt;int&gt;(cout, " "));
    cout &lt;&lt; endl;
    return (0);
}




</pre>

    </ul>

<p><br><a name="l207"></a>
<h3>10.3.64: unique()</h3>
    <a name="stl/unique"></a>
        <ul>
        <li > Header file: 
        <pre>
#include&lt;algorithm&gt;
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>ForwardIterator unique(ForwardIterator first, 
ForwardIterator last);</code>
            <li ><code>ForwardIterator unique(ForwardIterator first, 
ForwardIterator last, BinaryPredicate pred);</code>
        </ul>
        <li > Description:
        <ul>
            <li > The first prototype: Consecutively equal elements (according
to the <code>operator==()</code> of the underlying data type) in the range pointed to
by <code>[first, last)</code> are collapsed into a single element. The returned
forward iterator marks the <em>leftover</em> of the algorithm, and contains
(unique) elements appearing earlier in the range.
            <li > The second prototype: Consecutive elements in the range
pointed to by <code>[first, last)</code> for which the binary predicate <code>pred</code>
returns <code>true</code> are collapsed into a single element. The returned
forward iterator marks the <em>leftover</em> of the algorithm, and contains
(unique) elements appearing earlier in the range.
        </ul>
        <li > Example:
        <pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

class CaseString
{
    public:
        operator()(string const &amp;first, string const &amp;second) const
        {
            return (!strcasecmp(first.c_str(), second.c_str()));
        }
};

int main()
{
    string
        words[] = 
        {"alpha", "alpha", "Alpha", "papa", "quebec" },
        *removed;
    unsigned
        size = sizeof(words) / sizeof(string);

    removed = unique(words, words + size);
    copy(words, removed, ostream_iterator&lt;string&gt;(cout, " "));
    cout &lt;&lt; endl
         &lt;&lt; "Trailing elements are:\n";
    copy(removed, words + size, ostream_iterator&lt;string&gt;(cout, " "));
    cout &lt;&lt; endl;

    removed = unique(words, words + size, CaseString());
    copy(words, removed, ostream_iterator&lt;string&gt;(cout, " "));
    cout &lt;&lt; endl
         &lt;&lt; "Trailing elements are:\n";
    copy(removed, words + size, ostream_iterator&lt;string&gt;(cout, " "));
    cout &lt;&lt; endl;

    return (0);
}
</pre>

    </ul>

<p><br>
    <a name="UNIQUECOPY"></a><a name="l208"></a>
<h3>10.3.65: unique_copy()</h3>
    <a name="stl/uniquecopy"></a>
        <ul>
        <li > Header file: 
        <pre>
#include&lt;algorithm&gt;
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>OutputIterator unique_copy(InputIterator first, 
InputIterator last, OutputIterator result);</code>
            <li ><code>OutputIterator unique_copy(InputIterator first, 
InputIterator last, OutputIterator Result, BinaryPredicate pred);</code>
        </ul>
        <li > Description:
        <ul>
            <li > The first prototype: The elements in the range <code>[first,
last)</code> are copied to the resulting container, starting at <code>result</code>.
Consecutively equal elements (according to the <code>operator==()</code> of the
underlying data type) are copied only once. The returned output iterator
points just beyond the last element that was copied.
            <li > The second prototype: The elements in the range <code>[first,
last)</code> are copied to the resulting container, starting at <code>result</code>.
Consecutive elements in the range pointed to by <code>[first, last)</code> for which
the binary predicate <code>pred</code> returns <code>true</code> are copied only once. The
returned output iterator points just beyond the last element that was copied.
        </ul>
        <li > Example:
        <pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;functional&gt;

class CaseString
{
    public:
        operator()(string const &amp;first, string const &amp;second) const
        {
            return (!strcasecmp(first.c_str(), second.c_str()));
        }
};

int main()
{
    string
        words[] = {"oscar", "Alpha", "alpha", "alpha", "papa", "quebec" };
    unsigned
        size = sizeof(words) / sizeof(string);
    vector&lt;string&gt;
        remaining;

    unique_copy(words, words + size, 
                            back_inserter(remaining));
                                                
    copy(remaining.begin(), remaining.end(), 
            ostream_iterator&lt;string&gt;(cout, " "));
    cout &lt;&lt; endl;

    vector&lt;string&gt;
        remaining2;

    unique_copy(words, words + size, 
                            back_inserter(remaining2), CaseString());
                                                
    copy(remaining2.begin(), remaining2.end(), 
            ostream_iterator&lt;string&gt;(cout, " "));
    cout &lt;&lt; endl;

    return (0);
}
</pre>

    </ul>

<p><br>
    <a name="UPPERBOUND"></a><a name="l209"></a>
<h3>10.3.66: upper_bound()</h3>              
    <a name="stl/upperbound"></a>
        <ul>
        <li > Header files: 
        <pre>

        #include&lt;algorithm&gt;
        
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>ForwardIterator upper_bound(ForwardIterator first, 
ForwardIterator last, const Type &amp;value);</code>
            <li ><code>ForwardIterator upper_bound(ForwardIterator first, 
ForwardIterator last, const Type &amp;value, Compare comp);</code>
        </ul>
        <li > Description:
        <ul>
            <li > The first prototype: The sorted elements implied by the
iterator range <code>[first, last)</code> are searched for the first element that
that is greater than <code>value</code>. The returned iterator marks the location in
the sequence where <code>value</code> can be inserted without breaking the sorted order
of the elements. The <code>operator&lt;()</code> of the underlying datatype is used. If no
such element is found, <code>last</code> is returned.
            <li > The second prototype: The elements implied by the iterator
range <code>[first, last)</code> must have been sorted using the <code>comp</code> function
(-object). Each element in the range is compared to <code>value</code> using the
<code>comp</code> function. An iterator to the first element for which the binary
predicate <code>comp</code>, applied to the elements of the range and <code>value</code>,
returns <code>true</code> is returned.  If no such element is found, <code>last</code> is
returned.
        </ul>
        <li > Example:
        <pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;functional&gt;

int main()
{
    int 
        ia[] = {10, 20, 30};

    cout &lt;&lt; "Sequence: ";
    copy(ia, ia + 3, ostream_iterator&lt;int&gt;(cout, " "));
    cout &lt;&lt; endl;

    cout &lt;&lt; "15 can be inserted before " &lt;&lt;
            *upper_bound(ia, ia + 3, 15) &lt;&lt; endl;
    cout &lt;&lt; "35 can be inserted after " &lt;&lt;
            (upper_bound(ia, ia + 3, 35) == ia + 3 ? 
                                "the last element" : "???") &lt;&lt; endl;

    iter_swap(ia, ia + 2);

    cout &lt;&lt; "Sequence: ";
    copy(ia, ia + 3, ostream_iterator&lt;int&gt;(cout, " "));
    cout &lt;&lt; endl;

    cout &lt;&lt; "15 can be inserted before " &lt;&lt;
            *upper_bound(ia, ia + 3, 15, greater&lt;int&gt;()) &lt;&lt; endl;
    cout &lt;&lt; "35 can be inserted before " &lt;&lt;
            (upper_bound(ia, ia + 3, 35, greater&lt;int&gt;()) == ia ? 
                                "the first element " : "???") &lt;&lt; endl;

    return (0);
}
</pre>

    </ul>

<p><br><a name="l210"></a>
<h3>10.3.67: Heap algorithms</h3>
    <a name="stl/heap"></a>
    A heap is a form of binary tree represented as an array. In the standard heap,
the key of an  element is greater or equal to the key of its children. This
kind of heap is called a <em>max heap</em>.
<p><br>A tree in which numbers are keys could be organized as follows:
<p><br><a name="heaptree"></a><p><center><img src="images/heap.gif" align="bottom" alt="figure 11 is shown here."><br> 
figure 11: A binary tree representation of a heap 
</center><p><br>
    
<p><br>This tree can be organized in an array as follows:
<p><br><center><code>12, 11, 10, 8, 9, 7, 6, 1, 2, 4, 3, 5</code> </center>
<p><br>Here, 12 is the top node. its children are 11 and 10, both less than 12. 11,
in turn, has 8 and 9 as its children, while the children of 10 are 7 and 6. 8
has 1 and 2 as its children, 9 has 4 and 3, and finally, 7 has left child 5. 7
doesn't have a right child, and 6 has no children. 
<p><br>Note that the left and right branches are not ordered: 8 is less than 9, but 7
is larger than 6.
<p><br>The heap is formed by traversing a binary tree level-wise, starting from the
top node. The top node is 12, at the zeroth level. At the first level we find
11 and 10. At the second level 6, 7, 8 and 9 are found, etc.
<p><br>Heaps can be created in containers supporting random access. So, a heap is
not, for example, constructed in a list. Heaps can be constructed from an
(unsorted) array (using <a href="cplusplus10.html#MAKEHEAP">make_heap()</a>). The top-element can be
pruned from a heap, followed by reordering the heap (using
<a href="cplusplus10.html#POPHEAP">pop_heap()</a>), a new element can be added to the heap, followed
by reordering the heap (using <a href="cplusplus10.html#PUSHHEAP">push_heap()</a>), and the elements
in a heap can be sorted (using <a href="cplusplus10.html#SORTHEAP">sort_heap()</a>, which invalidates
the heap, though).
<p><br>The following subsections introduce the prototypes of the heap-algorithms, the
final subsection provides a small example in which the heap algorithms are
used. 
<p><br><a name="MAKEHEAP"></a>
<a name="l211"></a>

             
<strong>10.3.67.1: make_heap()</strong><p>
        <a name="stl/makeheap"></a>
        <ul>
        <li > Header files: 
        <pre>

        #include&lt;algorithm&gt;
        
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>void make_heap(RandomAccessIterator first,
RandomAccessIterator last);</code>
            <li ><code>void make_heap(RandomAccessIterator first,
RandomAccessIterator last, Compare comp);</code>
        </ul>
        <li > Description:
        <ul>
            <li > The first prototype: The elements in the range <code>[first,
last)</code> are reordered to form a max-heap, using the <code>operator&lt;()</code> of the
underlying data type.
            <li > The second prototype: The elements in the range <code>[first,
last)</code> are reordered to form a heap, using the binary comparison function
object <code>comp</code> to compare elements.
        </ul>
        <li > Follow this link for a small <a href="cplusplus10.html#HEAPDEMO">example</a> of a program
using <code>make_heap()</code>.
    </ul>

<p><br><a name="POPHEAP"></a>
<a name="l212"></a>

             
<strong>10.3.67.2: pop_heap()</strong><p>
        <a name="stl/popheap"></a>
        <ul>
        <li > Header files: 
        <pre>

        #include&lt;algorithm&gt;
        
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>void pop_heap(RandomAccessIterator first,
RandomAccessIterator last);</code>
            <li ><code>void pop_heap(RandomAccessIterator first,
RandomAccessIterator last, Compare comp);</code>
        </ul>
        <li > Description:
        <ul>
            <li > The first prototype: The first element in the range
<code>[first, last)</code> is moved to <code>last - 1</code>. Then, the elements in the range
<code>[first, last - 1)</code> are reordered to form a max-heap, using the
<code>operator&lt;()</code> of the underlying data type.
            <li > The second prototype: The first element in the range
<code>[first, last)</code> is moved to <code>last - 1</code>. Then, the elements in the range
<code>[first, last - 1)</code> are reordered to form a heap, using the binary
comparison function object <code>comp</code> to compare elements.
        </ul>
        <li > Follow this link for a small <a href="cplusplus10.html#HEAPDEMO">example</a> of a program
using <code>pop_heap()</code>.
    </ul>

<p><br><a name="PUSHHEAP"></a>
<a name="l213"></a>

             
<strong>10.3.67.3: push_heap()</strong><p>
        <a name="stl/pushheap"></a>
        <ul>
        <li > Header files: 
        <pre>

        #include&lt;algorithm&gt;
        
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>void push_heap(RandomAccessIterator first,
RandomAccessIterator last);</code>
            <li ><code>void push_heap(RandomAccessIterator first,
RandomAccessIterator last, Compare comp);</code>
        </ul>
        <li > Description:
        <ul>
            <li > The first prototype: Assuming that the range <code>[first,
last - 2)</code> contains a valid heap, and the element at <code>last - 1</code> contains an
element to be added to the heap, the elements in the range <code>[first, last
- 1)</code> are reordered to form a max-heap, using the <code>operator&lt;()</code> of the
underlying data type.
            <li > The second prototype: Assuming that the range <code>[first,
last - 2)</code> contains a valid heap, and the element at <code>last - 1</code> contains an
element to be added to the heap, the elements in the range <code>[first, last
- 1)</code> are reordered to form a heap, using the binary comparison function
object <code>comp</code> to compare elements.
        </ul>
        <li > Follow this link for a small <a href="cplusplus10.html#HEAPDEMO">example</a> of a program
using <code>push_heap()</code>.
<p><br></ul>

<p><br><a name="SORTHEAP"></a>
<a name="l214"></a>

             
<strong>10.3.67.4: sort_heap()</strong><p>
        <a name="stl/sortheap"></a>
        <ul>
        <li > Header files: 
        <pre>

        #include&lt;algorithm&gt;
        
</pre>

        <li > Function prototypes:
        <ul>
            <li ><code>void sort_heap(RandomAccessIterator first,
RandomAccessIterator last);</code>
            <li ><code>void sort_heap(RandomAccessIterator first,
RandomAccessIterator last, Compare comp);</code>
        </ul>
        <li > Description:
        <ul>
            <li > The first prototype: Assuming the elements in the range
<code>[first, last)</code> form a valid max-heap, the elements in the range
<code>[first, last)</code> are sorted, using the <code>operator&lt;()</code> of the underlying
data type.
            <li > The second prototype: Assuming the elements in the range
<code>[first, last)</code> form a valid heap, the elements in the range
<code>[first, last)</code> are sorted, using the binary comparison function
object <code>comp</code> to compare elements.
        </ul>
        <li > Follow this link for a small <a href="cplusplus10.html#HEAPDEMO">example</a> of a program
using <code>sort_heap()</code>.
<p><br></ul>

<p><br><a name="HEAPDEMO"></a>
<a name="l215"></a>

             
<strong>10.3.67.5: A small example using the heap algorithms</strong><p>
        <pre>
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;functional&gt;

void show(int *ia, char const *header)
{
    cout &lt;&lt; header &lt;&lt; ":\n";
    copy(ia, ia + 20, ostream_iterator&lt;int&gt;(cout, " "));
    cout &lt;&lt; endl;
}

int main()
{
    int
        ia[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 
                11, 12, 13, 14, 15, 16, 17, 18, 19, 20};

    make_heap(ia, ia + 20);
    show(ia, "The values 1-20 in a max-heap");

    pop_heap(ia, ia + 20);
    show(ia, "Removing the first element (now at the end)");

    push_heap(ia, ia + 20);
    show(ia, "Adding 20 (at the end) to the heap again");

    sort_heap(ia, ia + 20);
    show(ia, "Sorting the elements in the heap");


    make_heap(ia, ia + 20, greater&lt;int&gt;());
    show(ia, "The values 1-20 in a heap, using &gt; (and beyond too)");

    pop_heap(ia, ia + 20, greater&lt;int&gt;());
    show(ia, "Removing the first element (now at the end)");

    push_heap(ia, ia + 20, greater&lt;int&gt;());
    show(ia, "Adding 20 (at the end) to the heap again");

    sort_heap(ia, ia + 20, greater&lt;int&gt;());
    show(ia, "Sorting the elements in the heap");

    return (0);
}
</pre>


<p><br>


<hr>
<ul>
    <li> <a href="cplusplus11.html">Next chapter</a>
    <li> <a href="cplusplus09.html">Previous chapter</a>
    <li> <a href="cplusplus.html">Table of contents</a>
</ul>
<hr>
</body>
</html>
